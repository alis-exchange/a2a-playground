// Older protoc compilers don't understand edition yet.

// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file a2a.proto (package a2a.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_google_api_annotations } from "./google/api/annotations_pb";
import { file_google_api_client } from "./google/api/client_pb";
import { file_google_api_field_behavior } from "./google/api/field_behavior_pb";
import type { EmptySchema, Timestamp, Value } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { JsonObject, Message as Message$1 } from "@bufbuild/protobuf";

/**
 * Describes the file a2a.proto.
 */
export const file_a2a: GenFile = /*@__PURE__*/
  fileDesc("CglhMmEucHJvdG8SBmEyYS52MSK9AQoYU2VuZE1lc3NhZ2VDb25maWd1cmF0aW9uEh0KFWFjY2VwdGVkX291dHB1dF9tb2RlcxgBIAMoCRJAChhwdXNoX25vdGlmaWNhdGlvbl9jb25maWcYAiABKAsyHi5hMmEudjEuUHVzaE5vdGlmaWNhdGlvbkNvbmZpZxIbCg5oaXN0b3J5X2xlbmd0aBgDIAEoBUgAiAEBEhAKCGJsb2NraW5nGAQgASgIQhEKD19oaXN0b3J5X2xlbmd0aCLLAQoEVGFzaxIPCgJpZBgBIAEoCUID4EECEhcKCmNvbnRleHRfaWQYAiABKAlCA+BBAhInCgZzdGF0dXMYAyABKAsyEi5hMmEudjEuVGFza1N0YXR1c0ID4EECEiMKCWFydGlmYWN0cxgEIAMoCzIQLmEyYS52MS5BcnRpZmFjdBIgCgdoaXN0b3J5GAUgAygLMg8uYTJhLnYxLk1lc3NhZ2USKQoIbWV0YWRhdGEYBiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0IoQBCgpUYXNrU3RhdHVzEiUKBXN0YXRlGAEgASgOMhEuYTJhLnYxLlRhc2tTdGF0ZUID4EECEiAKB21lc3NhZ2UYAiABKAsyDy5hMmEudjEuTWVzc2FnZRItCgl0aW1lc3RhbXAYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIrgBCgRQYXJ0Eg4KBHRleHQYASABKAlIABINCgNyYXcYAiABKAxIABINCgN1cmwYAyABKAlIABImCgRkYXRhGAQgASgLMhYuZ29vZ2xlLnByb3RvYnVmLlZhbHVlSAASKQoIbWV0YWRhdGEYBSABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0EhAKCGZpbGVuYW1lGAYgASgJEhIKCm1lZGlhX3R5cGUYByABKAlCCQoHY29udGVudCLlAQoHTWVzc2FnZRIXCgptZXNzYWdlX2lkGAEgASgJQgPgQQISEgoKY29udGV4dF9pZBgCIAEoCRIPCgd0YXNrX2lkGAMgASgJEh8KBHJvbGUYBCABKA4yDC5hMmEudjEuUm9sZUID4EECEiAKBXBhcnRzGAUgAygLMgwuYTJhLnYxLlBhcnRCA+BBAhIpCghtZXRhZGF0YRgGIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QSEgoKZXh0ZW5zaW9ucxgHIAMoCRIaChJyZWZlcmVuY2VfdGFza19pZHMYCCADKAkiqAEKCEFydGlmYWN0EhgKC2FydGlmYWN0X2lkGAEgASgJQgPgQQISDAoEbmFtZRgDIAEoCRITCgtkZXNjcmlwdGlvbhgEIAEoCRIgCgVwYXJ0cxgFIAMoCzIMLmEyYS52MS5QYXJ0QgPgQQISKQoIbWV0YWRhdGEYBiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0EhIKCmV4dGVuc2lvbnMYByADKAkioAEKFVRhc2tTdGF0dXNVcGRhdGVFdmVudBIUCgd0YXNrX2lkGAEgASgJQgPgQQISFwoKY29udGV4dF9pZBgCIAEoCUID4EECEicKBnN0YXR1cxgDIAEoCzISLmEyYS52MS5UYXNrU3RhdHVzQgPgQQISKQoIbWV0YWRhdGEYBSABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0SgQIBBAFIsABChdUYXNrQXJ0aWZhY3RVcGRhdGVFdmVudBIUCgd0YXNrX2lkGAEgASgJQgPgQQISFwoKY29udGV4dF9pZBgCIAEoCUID4EECEicKCGFydGlmYWN0GAMgASgLMhAuYTJhLnYxLkFydGlmYWN0QgPgQQISDgoGYXBwZW5kGAQgASgIEhIKCmxhc3RfY2h1bmsYBSABKAgSKQoIbWV0YWRhdGEYBiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0InkKFlB1c2hOb3RpZmljYXRpb25Db25maWcSCgoCaWQYASABKAkSEAoDdXJsGAIgASgJQgPgQQISDQoFdG9rZW4YAyABKAkSMgoOYXV0aGVudGljYXRpb24YBCABKAsyGi5hMmEudjEuQXV0aGVudGljYXRpb25JbmZvIj4KEkF1dGhlbnRpY2F0aW9uSW5mbxITCgZzY2hlbWUYASABKAlCA+BBAhITCgtjcmVkZW50aWFscxgCIAEoCSJwCg5BZ2VudEludGVyZmFjZRIQCgN1cmwYASABKAlCA+BBAhIdChBwcm90b2NvbF9iaW5kaW5nGAIgASgJQgPgQQISDgoGdGVuYW50GAMgASgJEh0KEHByb3RvY29sX3ZlcnNpb24YBCABKAlCA+BBAiLMBQoJQWdlbnRDYXJkEhEKBG5hbWUYASABKAlCA+BBAhIYCgtkZXNjcmlwdGlvbhgCIAEoCUID4EECEjkKFHN1cHBvcnRlZF9pbnRlcmZhY2VzGBMgAygLMhYuYTJhLnYxLkFnZW50SW50ZXJmYWNlQgPgQQISJwoIcHJvdmlkZXIYBCABKAsyFS5hMmEudjEuQWdlbnRQcm92aWRlchIUCgd2ZXJzaW9uGAUgASgJQgPgQQISHgoRZG9jdW1lbnRhdGlvbl91cmwYBiABKAlIAIgBARI0CgxjYXBhYmlsaXRpZXMYByABKAsyGS5hMmEudjEuQWdlbnRDYXBhYmlsaXRpZXNCA+BBAhJAChBzZWN1cml0eV9zY2hlbWVzGAggAygLMiYuYTJhLnYxLkFnZW50Q2FyZC5TZWN1cml0eVNjaGVtZXNFbnRyeRI6ChVzZWN1cml0eV9yZXF1aXJlbWVudHMYDSADKAsyGy5hMmEudjEuU2VjdXJpdHlSZXF1aXJlbWVudBIgChNkZWZhdWx0X2lucHV0X21vZGVzGAogAygJQgPgQQISIQoUZGVmYXVsdF9vdXRwdXRfbW9kZXMYCyADKAlCA+BBAhInCgZza2lsbHMYDCADKAsyEi5hMmEudjEuQWdlbnRTa2lsbEID4EECEi4KCnNpZ25hdHVyZXMYESADKAsyGi5hMmEudjEuQWdlbnRDYXJkU2lnbmF0dXJlEhUKCGljb25fdXJsGBIgASgJSAGIAQEaTgoUU2VjdXJpdHlTY2hlbWVzRW50cnkSCwoDa2V5GAEgASgJEiUKBXZhbHVlGAIgASgLMhYuYTJhLnYxLlNlY3VyaXR5U2NoZW1lOgI4AUIUChJfZG9jdW1lbnRhdGlvbl91cmxCCwoJX2ljb25fdXJsSgQIAxAESgQICRAKSgQIDhAPSgQIDxAQSgQIEBARIjwKDUFnZW50UHJvdmlkZXISEAoDdXJsGAEgASgJQgPgQQISGQoMb3JnYW5pemF0aW9uGAIgASgJQgPgQQIi3QEKEUFnZW50Q2FwYWJpbGl0aWVzEhYKCXN0cmVhbWluZxgBIAEoCEgAiAEBEh8KEnB1c2hfbm90aWZpY2F0aW9ucxgCIAEoCEgBiAEBEioKCmV4dGVuc2lvbnMYAyADKAsyFi5hMmEudjEuQWdlbnRFeHRlbnNpb24SIAoTZXh0ZW5kZWRfYWdlbnRfY2FyZBgFIAEoCEgCiAEBQgwKCl9zdHJlYW1pbmdCFQoTX3B1c2hfbm90aWZpY2F0aW9uc0IWChRfZXh0ZW5kZWRfYWdlbnRfY2FyZEoECAQQBSJtCg5BZ2VudEV4dGVuc2lvbhILCgN1cmkYASABKAkSEwoLZGVzY3JpcHRpb24YAiABKAkSEAoIcmVxdWlyZWQYAyABKAgSJwoGcGFyYW1zGAQgASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCLWAQoKQWdlbnRTa2lsbBIPCgJpZBgBIAEoCUID4EECEhEKBG5hbWUYAiABKAlCA+BBAhIYCgtkZXNjcmlwdGlvbhgDIAEoCUID4EECEhEKBHRhZ3MYBCADKAlCA+BBAhIQCghleGFtcGxlcxgFIAMoCRITCgtpbnB1dF9tb2RlcxgGIAMoCRIUCgxvdXRwdXRfbW9kZXMYByADKAkSOgoVc2VjdXJpdHlfcmVxdWlyZW1lbnRzGAggAygLMhsuYTJhLnYxLlNlY3VyaXR5UmVxdWlyZW1lbnQibQoSQWdlbnRDYXJkU2lnbmF0dXJlEhYKCXByb3RlY3RlZBgBIAEoCUID4EECEhYKCXNpZ25hdHVyZRgCIAEoCUID4EECEicKBmhlYWRlchgDIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QimgEKGlRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnEg4KBnRlbmFudBgEIAEoCRIPCgJpZBgBIAEoCUID4EECEhQKB3Rhc2tfaWQYAyABKAlCA+BBAhJFChhwdXNoX25vdGlmaWNhdGlvbl9jb25maWcYAiABKAsyHi5hMmEudjEuUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ0ID4EECIhoKClN0cmluZ0xpc3QSDAoEbGlzdBgBIAMoCSKUAQoTU2VjdXJpdHlSZXF1aXJlbWVudBI5CgdzY2hlbWVzGAEgAygLMiguYTJhLnYxLlNlY3VyaXR5UmVxdWlyZW1lbnQuU2NoZW1lc0VudHJ5GkIKDFNjaGVtZXNFbnRyeRILCgNrZXkYASABKAkSIQoFdmFsdWUYAiABKAsyEi5hMmEudjEuU3RyaW5nTGlzdDoCOAEi8QIKDlNlY3VyaXR5U2NoZW1lEj8KF2FwaV9rZXlfc2VjdXJpdHlfc2NoZW1lGAEgASgLMhwuYTJhLnYxLkFQSUtleVNlY3VyaXR5U2NoZW1lSAASQwoZaHR0cF9hdXRoX3NlY3VyaXR5X3NjaGVtZRgCIAEoCzIeLmEyYS52MS5IVFRQQXV0aFNlY3VyaXR5U2NoZW1lSAASPgoWb2F1dGgyX3NlY3VyaXR5X3NjaGVtZRgDIAEoCzIcLmEyYS52MS5PQXV0aDJTZWN1cml0eVNjaGVtZUgAEk4KH29wZW5faWRfY29ubmVjdF9zZWN1cml0eV9zY2hlbWUYBCABKAsyIy5hMmEudjEuT3BlbklkQ29ubmVjdFNlY3VyaXR5U2NoZW1lSAASPwoUbXRsc19zZWN1cml0eV9zY2hlbWUYBSABKAsyHy5hMmEudjEuTXV0dWFsVGxzU2VjdXJpdHlTY2hlbWVIAEIICgZzY2hlbWUiVQoUQVBJS2V5U2VjdXJpdHlTY2hlbWUSEwoLZGVzY3JpcHRpb24YASABKAkSFQoIbG9jYXRpb24YAiABKAlCA+BBAhIRCgRuYW1lGAMgASgJQgPgQQIiWQoWSFRUUEF1dGhTZWN1cml0eVNjaGVtZRITCgtkZXNjcmlwdGlvbhgBIAEoCRITCgZzY2hlbWUYAiABKAlCA+BBAhIVCg1iZWFyZXJfZm9ybWF0GAMgASgJInAKFE9BdXRoMlNlY3VyaXR5U2NoZW1lEhMKC2Rlc2NyaXB0aW9uGAEgASgJEiYKBWZsb3dzGAIgASgLMhIuYTJhLnYxLk9BdXRoRmxvd3NCA+BBAhIbChNvYXV0aDJfbWV0YWRhdGFfdXJsGAMgASgJIlQKG09wZW5JZENvbm5lY3RTZWN1cml0eVNjaGVtZRITCgtkZXNjcmlwdGlvbhgBIAEoCRIgChNvcGVuX2lkX2Nvbm5lY3RfdXJsGAIgASgJQgPgQQIiLgoXTXV0dWFsVGxzU2VjdXJpdHlTY2hlbWUSEwoLZGVzY3JpcHRpb24YASABKAkisgIKCk9BdXRoRmxvd3MSQAoSYXV0aG9yaXphdGlvbl9jb2RlGAEgASgLMiIuYTJhLnYxLkF1dGhvcml6YXRpb25Db2RlT0F1dGhGbG93SAASQAoSY2xpZW50X2NyZWRlbnRpYWxzGAIgASgLMiIuYTJhLnYxLkNsaWVudENyZWRlbnRpYWxzT0F1dGhGbG93SAASMQoIaW1wbGljaXQYAyABKAsyGS5hMmEudjEuSW1wbGljaXRPQXV0aEZsb3dCAhgBSAASMQoIcGFzc3dvcmQYBCABKAsyGS5hMmEudjEuUGFzc3dvcmRPQXV0aEZsb3dCAhgBSAASMgoLZGV2aWNlX2NvZGUYBSABKAsyGy5hMmEudjEuRGV2aWNlQ29kZU9BdXRoRmxvd0gAQgYKBGZsb3ci9AEKGkF1dGhvcml6YXRpb25Db2RlT0F1dGhGbG93Eh4KEWF1dGhvcml6YXRpb25fdXJsGAEgASgJQgPgQQISFgoJdG9rZW5fdXJsGAIgASgJQgPgQQISEwoLcmVmcmVzaF91cmwYAyABKAkSQwoGc2NvcGVzGAQgAygLMi4uYTJhLnYxLkF1dGhvcml6YXRpb25Db2RlT0F1dGhGbG93LlNjb3Blc0VudHJ5QgPgQQISFQoNcGtjZV9yZXF1aXJlZBgFIAEoCBotCgtTY29wZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIr0BChpDbGllbnRDcmVkZW50aWFsc09BdXRoRmxvdxIWCgl0b2tlbl91cmwYASABKAlCA+BBAhITCgtyZWZyZXNoX3VybBgCIAEoCRJDCgZzY29wZXMYAyADKAsyLi5hMmEudjEuQ2xpZW50Q3JlZGVudGlhbHNPQXV0aEZsb3cuU2NvcGVzRW50cnlCA+BBAhotCgtTY29wZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIqkBChFJbXBsaWNpdE9BdXRoRmxvdxIZChFhdXRob3JpemF0aW9uX3VybBgBIAEoCRITCgtyZWZyZXNoX3VybBgCIAEoCRI1CgZzY29wZXMYAyADKAsyJS5hMmEudjEuSW1wbGljaXRPQXV0aEZsb3cuU2NvcGVzRW50cnkaLQoLU2NvcGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKhAQoRUGFzc3dvcmRPQXV0aEZsb3cSEQoJdG9rZW5fdXJsGAEgASgJEhMKC3JlZnJlc2hfdXJsGAIgASgJEjUKBnNjb3BlcxgDIAMoCzIlLmEyYS52MS5QYXNzd29yZE9BdXRoRmxvdy5TY29wZXNFbnRyeRotCgtTY29wZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBItYBChNEZXZpY2VDb2RlT0F1dGhGbG93EiUKGGRldmljZV9hdXRob3JpemF0aW9uX3VybBgBIAEoCUID4EECEhYKCXRva2VuX3VybBgCIAEoCUID4EECEhMKC3JlZnJlc2hfdXJsGAMgASgJEjwKBnNjb3BlcxgEIAMoCzInLmEyYS52MS5EZXZpY2VDb2RlT0F1dGhGbG93LlNjb3Blc0VudHJ5QgPgQQIaLQoLU2NvcGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKvAQoSU2VuZE1lc3NhZ2VSZXF1ZXN0Eg4KBnRlbmFudBgEIAEoCRIlCgdtZXNzYWdlGAEgASgLMg8uYTJhLnYxLk1lc3NhZ2VCA+BBAhI3Cg1jb25maWd1cmF0aW9uGAIgASgLMiAuYTJhLnYxLlNlbmRNZXNzYWdlQ29uZmlndXJhdGlvbhIpCghtZXRhZGF0YRgDIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QiYQoOR2V0VGFza1JlcXVlc3QSDgoGdGVuYW50GAMgASgJEg8KAmlkGAEgASgJQgPgQQISGwoOaGlzdG9yeV9sZW5ndGgYAiABKAVIAIgBAUIRCg9faGlzdG9yeV9sZW5ndGgitQIKEExpc3RUYXNrc1JlcXVlc3QSDgoGdGVuYW50GAkgASgJEhIKCmNvbnRleHRfaWQYASABKAkSIQoGc3RhdHVzGAIgASgOMhEuYTJhLnYxLlRhc2tTdGF0ZRIWCglwYWdlX3NpemUYAyABKAVIAIgBARISCgpwYWdlX3Rva2VuGAQgASgJEhsKDmhpc3RvcnlfbGVuZ3RoGAUgASgFSAGIAQESOgoWc3RhdHVzX3RpbWVzdGFtcF9hZnRlchgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASHgoRaW5jbHVkZV9hcnRpZmFjdHMYByABKAhIAogBAUIMCgpfcGFnZV9zaXplQhEKD19oaXN0b3J5X2xlbmd0aEIUChJfaW5jbHVkZV9hcnRpZmFjdHMihAEKEUxpc3RUYXNrc1Jlc3BvbnNlEiAKBXRhc2tzGAEgAygLMgwuYTJhLnYxLlRhc2tCA+BBAhIcCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAlCA+BBAhIWCglwYWdlX3NpemUYAyABKAVCA+BBAhIXCgp0b3RhbF9zaXplGAQgASgFQgPgQQIiNAoRQ2FuY2VsVGFza1JlcXVlc3QSDgoGdGVuYW50GAIgASgJEg8KAmlkGAEgASgJQgPgQQIiXQokR2V0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWdSZXF1ZXN0Eg4KBnRlbmFudBgCIAEoCRIUCgd0YXNrX2lkGAMgASgJQgPgQQISDwoCaWQYASABKAlCA+BBAiJgCidEZWxldGVUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1JlcXVlc3QSDgoGdGVuYW50GAIgASgJEhQKB3Rhc2tfaWQYAyABKAlCA+BBAhIPCgJpZBgBIAEoCUID4EECIqIBCidDcmVhdGVUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1JlcXVlc3QSDgoGdGVuYW50GAQgASgJEhQKB3Rhc2tfaWQYASABKAlCA+BBAhIWCgljb25maWdfaWQYAiABKAlCA+BBAhIzCgZjb25maWcYBSABKAsyHi5hMmEudjEuUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ0ID4EECSgQIAxAEIjkKFlN1YnNjcmliZVRvVGFza1JlcXVlc3QSDgoGdGVuYW50GAIgASgJEg8KAmlkGAEgASgJQgPgQQIidAolTGlzdFRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVxdWVzdBIOCgZ0ZW5hbnQYBCABKAkSFAoHdGFza19pZBgBIAEoCUID4EECEhEKCXBhZ2Vfc2l6ZRgCIAEoBRISCgpwYWdlX3Rva2VuGAMgASgJIi0KG0dldEV4dGVuZGVkQWdlbnRDYXJkUmVxdWVzdBIOCgZ0ZW5hbnQYASABKAkiYgoTU2VuZE1lc3NhZ2VSZXNwb25zZRIcCgR0YXNrGAEgASgLMgwuYTJhLnYxLlRhc2tIABIiCgdtZXNzYWdlGAIgASgLMg8uYTJhLnYxLk1lc3NhZ2VIAEIJCgdwYXlsb2FkItEBCg5TdHJlYW1SZXNwb25zZRIcCgR0YXNrGAEgASgLMgwuYTJhLnYxLlRhc2tIABIiCgdtZXNzYWdlGAIgASgLMg8uYTJhLnYxLk1lc3NhZ2VIABI2Cg1zdGF0dXNfdXBkYXRlGAMgASgLMh0uYTJhLnYxLlRhc2tTdGF0dXNVcGRhdGVFdmVudEgAEjoKD2FydGlmYWN0X3VwZGF0ZRgEIAEoCzIfLmEyYS52MS5UYXNrQXJ0aWZhY3RVcGRhdGVFdmVudEgAQgkKB3BheWxvYWQidgomTGlzdFRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVzcG9uc2USMwoHY29uZmlncxgBIAMoCzIiLmEyYS52MS5UYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZxIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkq+QEKCVRhc2tTdGF0ZRIaChZUQVNLX1NUQVRFX1VOU1BFQ0lGSUVEEAASGAoUVEFTS19TVEFURV9TVUJNSVRURUQQARIWChJUQVNLX1NUQVRFX1dPUktJTkcQAhIYChRUQVNLX1NUQVRFX0NPTVBMRVRFRBADEhUKEVRBU0tfU1RBVEVfRkFJTEVEEAQSFwoTVEFTS19TVEFURV9DQU5DRUxFRBAFEh0KGVRBU0tfU1RBVEVfSU5QVVRfUkVRVUlSRUQQBhIXChNUQVNLX1NUQVRFX1JFSkVDVEVEEAcSHAoYVEFTS19TVEFURV9BVVRIX1JFUVVJUkVEEAgqOwoEUm9sZRIUChBST0xFX1VOU1BFQ0lGSUVEEAASDQoJUk9MRV9VU0VSEAESDgoKUk9MRV9BR0VOVBACMuoOCgpBMkFTZXJ2aWNlEn0KC1NlbmRNZXNzYWdlEhouYTJhLnYxLlNlbmRNZXNzYWdlUmVxdWVzdBobLmEyYS52MS5TZW5kTWVzc2FnZVJlc3BvbnNlIjWC0+STAi86ASpaGzoBKiIWL3t0ZW5hbnR9L21lc3NhZ2U6c2VuZCINL21lc3NhZ2U6c2VuZBKHAQoUU2VuZFN0cmVhbWluZ01lc3NhZ2USGi5hMmEudjEuU2VuZE1lc3NhZ2VSZXF1ZXN0GhYuYTJhLnYxLlN0cmVhbVJlc3BvbnNlIjmC0+STAjM6ASpaHToBKiIYL3t0ZW5hbnR9L21lc3NhZ2U6c3RyZWFtIg8vbWVzc2FnZTpzdHJlYW0wARJlCgdHZXRUYXNrEhYuYTJhLnYxLkdldFRhc2tSZXF1ZXN0GgwuYTJhLnYxLlRhc2siNNpBAmlkgtPkkwIpWhgSFi97dGVuYW50fS90YXNrcy97aWQ9Kn0SDS90YXNrcy97aWQ9Kn0SYwoJTGlzdFRhc2tzEhguYTJhLnYxLkxpc3RUYXNrc1JlcXVlc3QaGS5hMmEudjEuTGlzdFRhc2tzUmVzcG9uc2UiIYLT5JMCG1oREg8ve3RlbmFudH0vdGFza3MSBi90YXNrcxJ6CgpDYW5jZWxUYXNrEhkuYTJhLnYxLkNhbmNlbFRhc2tSZXF1ZXN0GgwuYTJhLnYxLlRhc2siQ4LT5JMCPToBKloiOgEqIh0ve3RlbmFudH0vdGFza3Mve2lkPSp9OmNhbmNlbCIUL3Rhc2tzL3tpZD0qfTpjYW5jZWwSkAEKD1N1YnNjcmliZVRvVGFzaxIeLmEyYS52MS5TdWJzY3JpYmVUb1Rhc2tSZXF1ZXN0GhYuYTJhLnYxLlN0cmVhbVJlc3BvbnNlIkOC0+STAj1aIhIgL3t0ZW5hbnR9L3Rhc2tzL3tpZD0qfTpzdWJzY3JpYmUSFy90YXNrcy97aWQ9Kn06c3Vic2NyaWJlMAEShAIKIENyZWF0ZVRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnEi8uYTJhLnYxLkNyZWF0ZVRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVxdWVzdBoiLmEyYS52MS5UYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZyKKAdpBDnRhc2tfaWQsY29uZmlngtPkkwJzOgZjb25maWdaPToGY29uZmlnIjMve3RlbmFudH0vdGFza3Mve3Rhc2tfaWQ9Kn0vcHVzaE5vdGlmaWNhdGlvbkNvbmZpZ3MiKi90YXNrcy97dGFza19pZD0qfS9wdXNoTm90aWZpY2F0aW9uQ29uZmlncxL4AQodR2V0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWcSLC5hMmEudjEuR2V0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWdSZXF1ZXN0GiIuYTJhLnYxLlRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnIoQB2kEKdGFza19pZCxpZILT5JMCcVo8Ejove3RlbmFudH0vdGFza3Mve3Rhc2tfaWQ9Kn0vcHVzaE5vdGlmaWNhdGlvbkNvbmZpZ3Mve2lkPSp9EjEvdGFza3Mve3Rhc2tfaWQ9Kn0vcHVzaE5vdGlmaWNhdGlvbkNvbmZpZ3Mve2lkPSp9EvQBCh5MaXN0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWcSLS5hMmEudjEuTGlzdFRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVxdWVzdBouLmEyYS52MS5MaXN0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWdSZXNwb25zZSJz2kEHdGFza19pZILT5JMCY1o1EjMve3RlbmFudH0vdGFza3Mve3Rhc2tfaWQ9Kn0vcHVzaE5vdGlmaWNhdGlvbkNvbmZpZ3MSKi90YXNrcy97dGFza19pZD0qfS9wdXNoTm90aWZpY2F0aW9uQ29uZmlncxKJAQoUR2V0RXh0ZW5kZWRBZ2VudENhcmQSIy5hMmEudjEuR2V0RXh0ZW5kZWRBZ2VudENhcmRSZXF1ZXN0GhEuYTJhLnYxLkFnZW50Q2FyZCI5gtPkkwIzWh0SGy97dGVuYW50fS9leHRlbmRlZEFnZW50Q2FyZBISL2V4dGVuZGVkQWdlbnRDYXJkEvIBCiBEZWxldGVUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZxIvLmEyYS52MS5EZWxldGVUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1JlcXVlc3QaFi5nb29nbGUucHJvdG9idWYuRW1wdHkihAHaQQp0YXNrX2lkLGlkgtPkkwJxWjwqOi97dGVuYW50fS90YXNrcy97dGFza19pZD0qfS9wdXNoTm90aWZpY2F0aW9uQ29uZmlncy97aWQ9Kn0qMS90YXNrcy97dGFza19pZD0qfS9wdXNoTm90aWZpY2F0aW9uQ29uZmlncy97aWQ9Kn1CWQoRY29tLmdvb2dsZS5hMmEudjFCA0EyQVABWjRnaXRodWIuY29tL2FsaXMtZXhjaGFuZ2UvYTJhLXBsYXlncm91bmQvZ2VuL2dvL2EyYXBiqgIGQTJhLlYxYgZwcm90bzM", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_protobuf_empty, file_google_protobuf_struct, file_google_protobuf_timestamp]);

/**
 * --8<-- [start:SendMessageConfiguration]
 * Configuration of a send message request.
 *
 * @generated from message a2a.v1.SendMessageConfiguration
 */
export type SendMessageConfiguration = Message$1<"a2a.v1.SendMessageConfiguration"> & {
  /**
   * A list of media types the client is prepared to accept for response parts.
   * Agents SHOULD use this to tailor their output.
   *
   * @generated from field: repeated string accepted_output_modes = 1;
   */
  acceptedOutputModes: string[];

  /**
   * Configuration for the agent to send push notifications for task updates.
   *
   * @generated from field: a2a.v1.PushNotificationConfig push_notification_config = 2;
   */
  pushNotificationConfig?: PushNotificationConfig;

  /**
   * The maximum number of most recent messages from the task's history to
   * retrieve in the response. An unset value means the client does not impose
   * any limit. A value of zero is a request to not include any messages. The
   * server MUST NOT return more messages than the provided value, but MAY apply
   * a lower limit.
   *
   * @generated from field: optional int32 history_length = 3;
   */
  historyLength?: number;

  /**
   * If true, the operation waits until the task reaches a terminal or
   * interrupted state before returning. Default is false.
   *
   * @generated from field: bool blocking = 4;
   */
  blocking: boolean;
};

/**
 * Describes the message a2a.v1.SendMessageConfiguration.
 * Use `create(SendMessageConfigurationSchema)` to create a new message.
 */
export const SendMessageConfigurationSchema: GenMessage<SendMessageConfiguration> = /*@__PURE__*/
  messageDesc(file_a2a, 0);

/**
 * --8<-- [start:Task]
 * Task is the core unit of action for A2A. It has a current status
 * and when results are created for the task they are stored in the
 * artifact. If there are multiple turns for a task, these are stored in
 * history.
 *
 * @generated from message a2a.v1.Task
 */
export type Task = Message$1<"a2a.v1.Task"> & {
  /**
   * Unique identifier (e.g. UUID) for the task, generated by the server for a
   * new task.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Unique identifier (e.g. UUID) for the contextual collection of interactions
   * (tasks and messages). Created by the A2A server.
   *
   * @generated from field: string context_id = 2;
   */
  contextId: string;

  /**
   * The current status of a Task, including state and a message.
   *
   * @generated from field: a2a.v1.TaskStatus status = 3;
   */
  status?: TaskStatus;

  /**
   * A set of output artifacts for a Task.
   *
   * @generated from field: repeated a2a.v1.Artifact artifacts = 4;
   */
  artifacts: Artifact[];

  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * The history of interactions from a task.
   *
   * @generated from field: repeated a2a.v1.Message history = 5;
   */
  history: Message[];

  /**
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   * A key/value object to store custom metadata about a task.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message a2a.v1.Task.
 * Use `create(TaskSchema)` to create a new message.
 */
export const TaskSchema: GenMessage<Task> = /*@__PURE__*/
  messageDesc(file_a2a, 1);

/**
 * --8<-- [start:TaskStatus]
 * A container for the status of a task
 *
 * @generated from message a2a.v1.TaskStatus
 */
export type TaskStatus = Message$1<"a2a.v1.TaskStatus"> & {
  /**
   * The current state of this task.
   *
   * @generated from field: a2a.v1.TaskState state = 1;
   */
  state: TaskState;

  /**
   * A message associated with the status.
   *
   * @generated from field: a2a.v1.Message message = 2;
   */
  message?: Message;

  /**
   * ISO 8601 Timestamp when the status was recorded.
   * Example: "2023-10-27T10:00:00Z"
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;
};

/**
 * Describes the message a2a.v1.TaskStatus.
 * Use `create(TaskStatusSchema)` to create a new message.
 */
export const TaskStatusSchema: GenMessage<TaskStatus> = /*@__PURE__*/
  messageDesc(file_a2a, 2);

/**
 * --8<-- [start:Part]
 * Part represents a container for a section of communication content.
 * Parts can be purely textual, some sort of file (image, video, etc) or
 * a structured data blob (i.e. JSON).
 *
 * @generated from message a2a.v1.Part
 */
export type Part = Message$1<"a2a.v1.Part"> & {
  /**
   * @generated from oneof a2a.v1.Part.content
   */
  content: {
    /**
     * The string content of the text part.
     *
     * @generated from field: string text = 1;
     */
    value: string;
    case: "text";
  } | {
    /**
     * The raw byte content of a file. In JSON serialization, this is encoded as
     * a base64 string.
     *
     * @generated from field: bytes raw = 2;
     */
    value: Uint8Array;
    case: "raw";
  } | {
    /**
     * A URL pointing to the file's content.
     *
     * @generated from field: string url = 3;
     */
    value: string;
    case: "url";
  } | {
    /**
     * Arbitrary structured data as a JSON value (object, array, string, number,
     * boolean, or null).
     *
     * @generated from field: google.protobuf.Value data = 4;
     */
    value: Value;
    case: "data";
  } | { case: undefined; value?: undefined };

  /**
   * Optional metadata associated with this part.
   *
   * @generated from field: google.protobuf.Struct metadata = 5;
   */
  metadata?: JsonObject;

  /**
   * An optional name for the file (e.g., "document.pdf").
   *
   * @generated from field: string filename = 6;
   */
  filename: string;

  /**
   * The media type (MIME type) of the part content (e.g., "text/plain",
   * "application/json", "image/png"). This field is available for all part
   * types.
   *
   * @generated from field: string media_type = 7;
   */
  mediaType: string;
};

/**
 * Describes the message a2a.v1.Part.
 * Use `create(PartSchema)` to create a new message.
 */
export const PartSchema: GenMessage<Part> = /*@__PURE__*/
  messageDesc(file_a2a, 3);

/**
 * --8<-- [start:Message]
 * Message is one unit of communication between client and server. It can be
 * associated with a context and/or a task. For server messages, context_id must
 * be provided, and task_id only if a task was created. For client messages,
 * both fields are optional, with the caveat that if both are provided, they
 * have to match (the context_id has to be the one that is set on the task). If
 * only task_id is provided, the server will infer context_id from it.
 *
 * @generated from message a2a.v1.Message
 */
export type Message = Message$1<"a2a.v1.Message"> & {
  /**
   * The unique identifier (e.g. UUID) of the message. This is required and
   * created by the message creator.
   *
   * @generated from field: string message_id = 1;
   */
  messageId: string;

  /**
   * The context id of the message. This is optional and if set, the message
   * will be associated with the given context.
   *
   * @generated from field: string context_id = 2;
   */
  contextId: string;

  /**
   * The task id of the message. This is optional and if set, the message
   * will be associated with the given task.
   *
   * @generated from field: string task_id = 3;
   */
  taskId: string;

  /**
   * Identifies the sender of the message.
   *
   * @generated from field: a2a.v1.Role role = 4;
   */
  role: Role;

  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * Parts is the container of the message content.
   *
   * @generated from field: repeated a2a.v1.Part parts = 5;
   */
  parts: Part[];

  /**
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   * Any optional metadata to provide along with the message.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;

  /**
   * The URIs of extensions that are present or contributed to this Message.
   *
   * @generated from field: repeated string extensions = 7;
   */
  extensions: string[];

  /**
   * A list of task IDs that this message references for additional context.
   *
   * @generated from field: repeated string reference_task_ids = 8;
   */
  referenceTaskIds: string[];
};

/**
 * Describes the message a2a.v1.Message.
 * Use `create(MessageSchema)` to create a new message.
 */
export const MessageSchema: GenMessage<Message> = /*@__PURE__*/
  messageDesc(file_a2a, 4);

/**
 * --8<-- [start:Artifact]
 * Artifacts represent task outputs.
 *
 * @generated from message a2a.v1.Artifact
 */
export type Artifact = Message$1<"a2a.v1.Artifact"> & {
  /**
   * Unique identifier (e.g. UUID) for the artifact. It must be at least unique
   * within a task.
   *
   * @generated from field: string artifact_id = 1;
   */
  artifactId: string;

  /**
   * A human readable name for the artifact.
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * A human readable description of the artifact, optional.
   *
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * The content of the artifact. Must contain at least one part.
   *
   * @generated from field: repeated a2a.v1.Part parts = 5;
   */
  parts: Part[];

  /**
   * Optional metadata included with the artifact.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;

  /**
   * The URIs of extensions that are present or contributed to this Artifact.
   *
   * @generated from field: repeated string extensions = 7;
   */
  extensions: string[];
};

/**
 * Describes the message a2a.v1.Artifact.
 * Use `create(ArtifactSchema)` to create a new message.
 */
export const ArtifactSchema: GenMessage<Artifact> = /*@__PURE__*/
  messageDesc(file_a2a, 5);

/**
 * --8<-- [start:TaskStatusUpdateEvent]
 * An event sent by the agent to notify the client of a change in a task's
 * status.
 *
 * @generated from message a2a.v1.TaskStatusUpdateEvent
 */
export type TaskStatusUpdateEvent = Message$1<"a2a.v1.TaskStatusUpdateEvent"> & {
  /**
   * The id of the task that is changed
   *
   * @generated from field: string task_id = 1;
   */
  taskId: string;

  /**
   * The id of the context that the task belongs to
   *
   * @generated from field: string context_id = 2;
   */
  contextId: string;

  /**
   * The new status of the task.
   *
   * @generated from field: a2a.v1.TaskStatus status = 3;
   */
  status?: TaskStatus;

  /**
   * Optional metadata to associate with the task update.
   *
   * @generated from field: google.protobuf.Struct metadata = 5;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message a2a.v1.TaskStatusUpdateEvent.
 * Use `create(TaskStatusUpdateEventSchema)` to create a new message.
 */
export const TaskStatusUpdateEventSchema: GenMessage<TaskStatusUpdateEvent> = /*@__PURE__*/
  messageDesc(file_a2a, 6);

/**
 * --8<-- [start:TaskArtifactUpdateEvent]
 * TaskArtifactUpdateEvent represents a task delta where an artifact has
 * been generated.
 *
 * @generated from message a2a.v1.TaskArtifactUpdateEvent
 */
export type TaskArtifactUpdateEvent = Message$1<"a2a.v1.TaskArtifactUpdateEvent"> & {
  /**
   * The id of the task for this artifact.
   *
   * @generated from field: string task_id = 1;
   */
  taskId: string;

  /**
   * The id of the context that this task belongs to.
   *
   * @generated from field: string context_id = 2;
   */
  contextId: string;

  /**
   * The artifact that was generated or updated.
   *
   * @generated from field: a2a.v1.Artifact artifact = 3;
   */
  artifact?: Artifact;

  /**
   * If true, the content of this artifact should be appended to a previously
   * sent artifact with the same ID.
   *
   * @generated from field: bool append = 4;
   */
  append: boolean;

  /**
   * If true, this is the final chunk of the artifact.
   *
   * @generated from field: bool last_chunk = 5;
   */
  lastChunk: boolean;

  /**
   * Optional metadata associated with the artifact update.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message a2a.v1.TaskArtifactUpdateEvent.
 * Use `create(TaskArtifactUpdateEventSchema)` to create a new message.
 */
export const TaskArtifactUpdateEventSchema: GenMessage<TaskArtifactUpdateEvent> = /*@__PURE__*/
  messageDesc(file_a2a, 7);

/**
 * --8<-- [start:PushNotificationConfig]
 * Configuration for setting up push notifications for task updates.
 *
 * @generated from message a2a.v1.PushNotificationConfig
 */
export type PushNotificationConfig = Message$1<"a2a.v1.PushNotificationConfig"> & {
  /**
   * A unique identifier (e.g. UUID) for this push notification.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Url to send the notification too
   *
   * @generated from field: string url = 2;
   */
  url: string;

  /**
   * Token unique for this task/session
   *
   * @generated from field: string token = 3;
   */
  token: string;

  /**
   * Authentication information required to send the notification
   *
   * @generated from field: a2a.v1.AuthenticationInfo authentication = 4;
   */
  authentication?: AuthenticationInfo;
};

/**
 * Describes the message a2a.v1.PushNotificationConfig.
 * Use `create(PushNotificationConfigSchema)` to create a new message.
 */
export const PushNotificationConfigSchema: GenMessage<PushNotificationConfig> = /*@__PURE__*/
  messageDesc(file_a2a, 8);

/**
 * --8<-- [start:PushNotificationAuthenticationInfo]
 * Defines authentication details, used for push notifications.
 *
 * @generated from message a2a.v1.AuthenticationInfo
 */
export type AuthenticationInfo = Message$1<"a2a.v1.AuthenticationInfo"> & {
  /**
   * HTTP Authentication Scheme from the [IANA
   * registry](https://www.iana.org/assignments/http-authschemes/). Common
   * values: `Bearer`, `Basic`, `Digest`. Scheme names are case-insensitive per
   * [RFC 9110
   * Section 11.1](https://www.rfc-editor.org/rfc/rfc9110#section-11.1).
   *
   * @generated from field: string scheme = 1;
   */
  scheme: string;

  /**
   * Push Notification credentials. Format depends on the scheme (e.g., token
   * for Bearer).
   *
   * @generated from field: string credentials = 2;
   */
  credentials: string;
};

/**
 * Describes the message a2a.v1.AuthenticationInfo.
 * Use `create(AuthenticationInfoSchema)` to create a new message.
 */
export const AuthenticationInfoSchema: GenMessage<AuthenticationInfo> = /*@__PURE__*/
  messageDesc(file_a2a, 9);

/**
 * --8<-- [start:AgentInterface]
 * Declares a combination of a target URL, transport and protocol version for
 * interacting with the agent. This allows agents to expose the same
 * functionality over multiple protocol binding mechanisms.
 *
 * @generated from message a2a.v1.AgentInterface
 */
export type AgentInterface = Message$1<"a2a.v1.AgentInterface"> & {
  /**
   * The URL where this interface is available. Must be a valid absolute HTTPS
   * URL in production. Example: "https://api.example.com/a2a/v1",
   * "https://grpc.example.com/a2a"
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * The protocol binding supported at this URL. This is an open form string, to
   * be easily extended for other protocol bindings. The core ones officially
   * supported are `JSONRPC`, `GRPC` and `HTTP+JSON`.
   *
   * @generated from field: string protocol_binding = 2;
   */
  protocolBinding: string;

  /**
   * Tenant to be set in the request when calling the agent.
   *
   * @generated from field: string tenant = 3;
   */
  tenant: string;

  /**
   * The version of the A2A protocol this interface exposes.
   * Use the latest supported minor version per major version.
   * Examples: "0.3", "1.0"
   *
   * @generated from field: string protocol_version = 4;
   */
  protocolVersion: string;
};

/**
 * Describes the message a2a.v1.AgentInterface.
 * Use `create(AgentInterfaceSchema)` to create a new message.
 */
export const AgentInterfaceSchema: GenMessage<AgentInterface> = /*@__PURE__*/
  messageDesc(file_a2a, 10);

/**
 * --8<-- [start:AgentCard]
 * AgentCard is a self-describing manifest for an agent. It provides essential
 * metadata including the agent's identity, capabilities, skills, supported
 * communication methods, and security requirements.
 * Next ID: 20
 *
 * @generated from message a2a.v1.AgentCard
 */
export type AgentCard = Message$1<"a2a.v1.AgentCard"> & {
  /**
   * A human readable name for the agent.
   * Example: "Recipe Agent"
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A human-readable description of the agent, assisting users and other agents
   * in understanding its purpose.
   * Example: "Agent that helps users with recipes and cooking."
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * Ordered list of supported interfaces. First entry is preferred.
   *
   * @generated from field: repeated a2a.v1.AgentInterface supported_interfaces = 19;
   */
  supportedInterfaces: AgentInterface[];

  /**
   * The service provider of the agent.
   *
   * @generated from field: a2a.v1.AgentProvider provider = 4;
   */
  provider?: AgentProvider;

  /**
   * The version of the agent.
   * Example: "1.0.0"
   *
   * @generated from field: string version = 5;
   */
  version: string;

  /**
   * A url to provide additional documentation about the agent.
   *
   * @generated from field: optional string documentation_url = 6;
   */
  documentationUrl?: string;

  /**
   * A2A Capability set supported by the agent.
   *
   * @generated from field: a2a.v1.AgentCapabilities capabilities = 7;
   */
  capabilities?: AgentCapabilities;

  /**
   * The security scheme details used for authenticating with this agent.
   *
   * @generated from field: map<string, a2a.v1.SecurityScheme> security_schemes = 8;
   */
  securitySchemes: { [key: string]: SecurityScheme };

  /**
   * Security requirements for contacting the agent.
   *
   * @generated from field: repeated a2a.v1.SecurityRequirement security_requirements = 13;
   */
  securityRequirements: SecurityRequirement[];

  /**
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   * The set of interaction modes that the agent supports across all skills.
   * This can be overridden per skill. Defined as media types.
   *
   * @generated from field: repeated string default_input_modes = 10;
   */
  defaultInputModes: string[];

  /**
   * The media types supported as outputs from this agent.
   *
   * @generated from field: repeated string default_output_modes = 11;
   */
  defaultOutputModes: string[];

  /**
   * Skills represent an ability of an agent. It is largely
   * a descriptive concept but represents a more focused set of behaviors that
   * the agent is likely to succeed at.
   *
   * @generated from field: repeated a2a.v1.AgentSkill skills = 12;
   */
  skills: AgentSkill[];

  /**
   * JSON Web Signatures computed for this AgentCard.
   *
   * @generated from field: repeated a2a.v1.AgentCardSignature signatures = 17;
   */
  signatures: AgentCardSignature[];

  /**
   * An optional URL to an icon for the agent.
   *
   * @generated from field: optional string icon_url = 18;
   */
  iconUrl?: string;
};

/**
 * Describes the message a2a.v1.AgentCard.
 * Use `create(AgentCardSchema)` to create a new message.
 */
export const AgentCardSchema: GenMessage<AgentCard> = /*@__PURE__*/
  messageDesc(file_a2a, 11);

/**
 * --8<-- [start:AgentProvider]
 * Represents the service provider of an agent.
 *
 * @generated from message a2a.v1.AgentProvider
 */
export type AgentProvider = Message$1<"a2a.v1.AgentProvider"> & {
  /**
   * A URL for the agent provider's website or relevant documentation.
   * Example: "https://ai.google.dev"
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * The name of the agent provider's organization.
   * Example: "Google"
   *
   * @generated from field: string organization = 2;
   */
  organization: string;
};

/**
 * Describes the message a2a.v1.AgentProvider.
 * Use `create(AgentProviderSchema)` to create a new message.
 */
export const AgentProviderSchema: GenMessage<AgentProvider> = /*@__PURE__*/
  messageDesc(file_a2a, 12);

/**
 * --8<-- [start:AgentCapabilities]
 * Defines optional capabilities supported by an agent.
 *
 * @generated from message a2a.v1.AgentCapabilities
 */
export type AgentCapabilities = Message$1<"a2a.v1.AgentCapabilities"> & {
  /**
   * Indicates if the agent supports streaming responses.
   *
   * @generated from field: optional bool streaming = 1;
   */
  streaming?: boolean;

  /**
   * Indicates if the agent supports sending push notifications for asynchronous
   * task updates.
   *
   * @generated from field: optional bool push_notifications = 2;
   */
  pushNotifications?: boolean;

  /**
   * A list of protocol extensions supported by the agent.
   *
   * @generated from field: repeated a2a.v1.AgentExtension extensions = 3;
   */
  extensions: AgentExtension[];

  /**
   * Indicates if the agent supports providing an extended agent card when
   * authenticated.
   *
   * @generated from field: optional bool extended_agent_card = 5;
   */
  extendedAgentCard?: boolean;
};

/**
 * Describes the message a2a.v1.AgentCapabilities.
 * Use `create(AgentCapabilitiesSchema)` to create a new message.
 */
export const AgentCapabilitiesSchema: GenMessage<AgentCapabilities> = /*@__PURE__*/
  messageDesc(file_a2a, 13);

/**
 * --8<-- [start:AgentExtension]
 * A declaration of a protocol extension supported by an Agent.
 *
 * @generated from message a2a.v1.AgentExtension
 */
export type AgentExtension = Message$1<"a2a.v1.AgentExtension"> & {
  /**
   * The unique URI identifying the extension.
   *
   * @generated from field: string uri = 1;
   */
  uri: string;

  /**
   * A human-readable description of how this agent uses the extension.
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * If true, the client must understand and comply with the extension's
   * requirements.
   *
   * @generated from field: bool required = 3;
   */
  required: boolean;

  /**
   * Optional, extension-specific configuration parameters.
   *
   * @generated from field: google.protobuf.Struct params = 4;
   */
  params?: JsonObject;
};

/**
 * Describes the message a2a.v1.AgentExtension.
 * Use `create(AgentExtensionSchema)` to create a new message.
 */
export const AgentExtensionSchema: GenMessage<AgentExtension> = /*@__PURE__*/
  messageDesc(file_a2a, 14);

/**
 * --8<-- [start:AgentSkill]
 * Represents a distinct capability or function that an agent can perform.
 *
 * @generated from message a2a.v1.AgentSkill
 */
export type AgentSkill = Message$1<"a2a.v1.AgentSkill"> & {
  /**
   * A unique identifier for the agent's skill.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * A human-readable name for the skill.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * A detailed description of the skill.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * A set of keywords describing the skill's capabilities.
   *
   * @generated from field: repeated string tags = 4;
   */
  tags: string[];

  /**
   * Example prompts or scenarios that this skill can handle.
   *
   * @generated from field: repeated string examples = 5;
   */
  examples: string[];

  /**
   * The set of supported input media types for this skill, overriding the
   * agent's defaults.
   *
   * @generated from field: repeated string input_modes = 6;
   */
  inputModes: string[];

  /**
   * The set of supported output media types for this skill, overriding the
   * agent's defaults.
   *
   * @generated from field: repeated string output_modes = 7;
   */
  outputModes: string[];

  /**
   * Security schemes necessary for this skill.
   *
   * @generated from field: repeated a2a.v1.SecurityRequirement security_requirements = 8;
   */
  securityRequirements: SecurityRequirement[];
};

/**
 * Describes the message a2a.v1.AgentSkill.
 * Use `create(AgentSkillSchema)` to create a new message.
 */
export const AgentSkillSchema: GenMessage<AgentSkill> = /*@__PURE__*/
  messageDesc(file_a2a, 15);

/**
 * --8<-- [start:AgentCardSignature]
 * AgentCardSignature represents a JWS signature of an AgentCard.
 * This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
 *
 * @generated from message a2a.v1.AgentCardSignature
 */
export type AgentCardSignature = Message$1<"a2a.v1.AgentCardSignature"> & {
  /**
   * The protected JWS header for the signature. This is always a
   * base64url-encoded JSON object. Required.
   *
   * @generated from field: string protected = 1;
   */
  protected: string;

  /**
   * The computed signature, base64url-encoded. Required.
   *
   * @generated from field: string signature = 2;
   */
  signature: string;

  /**
   * The unprotected JWS header values.
   *
   * @generated from field: google.protobuf.Struct header = 3;
   */
  header?: JsonObject;
};

/**
 * Describes the message a2a.v1.AgentCardSignature.
 * Use `create(AgentCardSignatureSchema)` to create a new message.
 */
export const AgentCardSignatureSchema: GenMessage<AgentCardSignature> = /*@__PURE__*/
  messageDesc(file_a2a, 16);

/**
 * --8<-- [start:TaskPushNotificationConfig]
 * A container associating a push notification configuration with a specific
 * task.
 *
 * @generated from message a2a.v1.TaskPushNotificationConfig
 */
export type TaskPushNotificationConfig = Message$1<"a2a.v1.TaskPushNotificationConfig"> & {
  /**
   * Optional tenant
   *
   * @generated from field: string tenant = 4;
   */
  tenant: string;

  /**
   * The id of the config.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The id of the task this config is associated with.
   *
   * @generated from field: string task_id = 3;
   */
  taskId: string;

  /**
   * The push notification configuration details.
   *
   * @generated from field: a2a.v1.PushNotificationConfig push_notification_config = 2;
   */
  pushNotificationConfig?: PushNotificationConfig;
};

/**
 * Describes the message a2a.v1.TaskPushNotificationConfig.
 * Use `create(TaskPushNotificationConfigSchema)` to create a new message.
 */
export const TaskPushNotificationConfigSchema: GenMessage<TaskPushNotificationConfig> = /*@__PURE__*/
  messageDesc(file_a2a, 17);

/**
 * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
 *
 * @generated from message a2a.v1.StringList
 */
export type StringList = Message$1<"a2a.v1.StringList"> & {
  /**
   * @generated from field: repeated string list = 1;
   */
  list: string[];
};

/**
 * Describes the message a2a.v1.StringList.
 * Use `create(StringListSchema)` to create a new message.
 */
export const StringListSchema: GenMessage<StringList> = /*@__PURE__*/
  messageDesc(file_a2a, 18);

/**
 * @generated from message a2a.v1.SecurityRequirement
 */
export type SecurityRequirement = Message$1<"a2a.v1.SecurityRequirement"> & {
  /**
   * @generated from field: map<string, a2a.v1.StringList> schemes = 1;
   */
  schemes: { [key: string]: StringList };
};

/**
 * Describes the message a2a.v1.SecurityRequirement.
 * Use `create(SecurityRequirementSchema)` to create a new message.
 */
export const SecurityRequirementSchema: GenMessage<SecurityRequirement> = /*@__PURE__*/
  messageDesc(file_a2a, 19);

/**
 * --8<-- [start:SecurityScheme]
 * Defines a security scheme that can be used to secure an agent's endpoints.
 * This is a discriminated union type based on the OpenAPI 3.2 Security Scheme
 * Object. See: https://spec.openapis.org/oas/v3.2.0.html#security-scheme-object
 *
 * @generated from message a2a.v1.SecurityScheme
 */
export type SecurityScheme = Message$1<"a2a.v1.SecurityScheme"> & {
  /**
   * @generated from oneof a2a.v1.SecurityScheme.scheme
   */
  scheme: {
    /**
     * API key-based authentication.
     *
     * @generated from field: a2a.v1.APIKeySecurityScheme api_key_security_scheme = 1;
     */
    value: APIKeySecurityScheme;
    case: "apiKeySecurityScheme";
  } | {
    /**
     * HTTP authentication (Basic, Bearer, etc.).
     *
     * @generated from field: a2a.v1.HTTPAuthSecurityScheme http_auth_security_scheme = 2;
     */
    value: HTTPAuthSecurityScheme;
    case: "httpAuthSecurityScheme";
  } | {
    /**
     * OAuth 2.0 authentication.
     *
     * @generated from field: a2a.v1.OAuth2SecurityScheme oauth2_security_scheme = 3;
     */
    value: OAuth2SecurityScheme;
    case: "oauth2SecurityScheme";
  } | {
    /**
     * OpenID Connect authentication.
     *
     * @generated from field: a2a.v1.OpenIdConnectSecurityScheme open_id_connect_security_scheme = 4;
     */
    value: OpenIdConnectSecurityScheme;
    case: "openIdConnectSecurityScheme";
  } | {
    /**
     * Mutual TLS authentication.
     *
     * @generated from field: a2a.v1.MutualTlsSecurityScheme mtls_security_scheme = 5;
     */
    value: MutualTlsSecurityScheme;
    case: "mtlsSecurityScheme";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message a2a.v1.SecurityScheme.
 * Use `create(SecuritySchemeSchema)` to create a new message.
 */
export const SecuritySchemeSchema: GenMessage<SecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 20);

/**
 * --8<-- [start:APIKeySecurityScheme]
 * Defines a security scheme using an API key.
 *
 * @generated from message a2a.v1.APIKeySecurityScheme
 */
export type APIKeySecurityScheme = Message$1<"a2a.v1.APIKeySecurityScheme"> & {
  /**
   * An optional description for the security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * The location of the API key. Valid values are "query", "header", or
   * "cookie".
   *
   * @generated from field: string location = 2;
   */
  location: string;

  /**
   * The name of the header, query, or cookie parameter to be used.
   *
   * @generated from field: string name = 3;
   */
  name: string;
};

/**
 * Describes the message a2a.v1.APIKeySecurityScheme.
 * Use `create(APIKeySecuritySchemeSchema)` to create a new message.
 */
export const APIKeySecuritySchemeSchema: GenMessage<APIKeySecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 21);

/**
 * --8<-- [start:HTTPAuthSecurityScheme]
 * Defines a security scheme using HTTP authentication.
 *
 * @generated from message a2a.v1.HTTPAuthSecurityScheme
 */
export type HTTPAuthSecurityScheme = Message$1<"a2a.v1.HTTPAuthSecurityScheme"> & {
  /**
   * An optional description for the security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * The name of the HTTP Authentication scheme to be used in the Authorization
   * header, as defined in RFC7235 (e.g., "Bearer"). This value should be
   * registered in the IANA Authentication Scheme registry.
   *
   * @generated from field: string scheme = 2;
   */
  scheme: string;

  /**
   * A hint to the client to identify how the bearer token is formatted (e.g.,
   * "JWT"). This is primarily for documentation purposes.
   *
   * @generated from field: string bearer_format = 3;
   */
  bearerFormat: string;
};

/**
 * Describes the message a2a.v1.HTTPAuthSecurityScheme.
 * Use `create(HTTPAuthSecuritySchemeSchema)` to create a new message.
 */
export const HTTPAuthSecuritySchemeSchema: GenMessage<HTTPAuthSecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 22);

/**
 * --8<-- [start:OAuth2SecurityScheme]
 * Defines a security scheme using OAuth 2.0.
 *
 * @generated from message a2a.v1.OAuth2SecurityScheme
 */
export type OAuth2SecurityScheme = Message$1<"a2a.v1.OAuth2SecurityScheme"> & {
  /**
   * An optional description for the security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * An object containing configuration information for the supported OAuth 2.0
   * flows.
   *
   * @generated from field: a2a.v1.OAuthFlows flows = 2;
   */
  flows?: OAuthFlows;

  /**
   * URL to the oauth2 authorization server metadata
   * RFC8414 (https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
   *
   * @generated from field: string oauth2_metadata_url = 3;
   */
  oauth2MetadataUrl: string;
};

/**
 * Describes the message a2a.v1.OAuth2SecurityScheme.
 * Use `create(OAuth2SecuritySchemeSchema)` to create a new message.
 */
export const OAuth2SecuritySchemeSchema: GenMessage<OAuth2SecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 23);

/**
 * --8<-- [start:OpenIdConnectSecurityScheme]
 * Defines a security scheme using OpenID Connect.
 *
 * @generated from message a2a.v1.OpenIdConnectSecurityScheme
 */
export type OpenIdConnectSecurityScheme = Message$1<"a2a.v1.OpenIdConnectSecurityScheme"> & {
  /**
   * An optional description for the security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * The OpenID Connect Discovery URL for the OIDC provider's metadata.
   * See: https://openid.net/specs/openid-connect-discovery-1_0.html
   *
   * @generated from field: string open_id_connect_url = 2;
   */
  openIdConnectUrl: string;
};

/**
 * Describes the message a2a.v1.OpenIdConnectSecurityScheme.
 * Use `create(OpenIdConnectSecuritySchemeSchema)` to create a new message.
 */
export const OpenIdConnectSecuritySchemeSchema: GenMessage<OpenIdConnectSecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 24);

/**
 * --8<-- [start:MutualTLSSecurityScheme]
 * Defines a security scheme using mTLS authentication.
 *
 * @generated from message a2a.v1.MutualTlsSecurityScheme
 */
export type MutualTlsSecurityScheme = Message$1<"a2a.v1.MutualTlsSecurityScheme"> & {
  /**
   * An optional description for the security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;
};

/**
 * Describes the message a2a.v1.MutualTlsSecurityScheme.
 * Use `create(MutualTlsSecuritySchemeSchema)` to create a new message.
 */
export const MutualTlsSecuritySchemeSchema: GenMessage<MutualTlsSecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 25);

/**
 * --8<-- [start:OAuthFlows]
 * Defines the configuration for the supported OAuth 2.0 flows.
 *
 * @generated from message a2a.v1.OAuthFlows
 */
export type OAuthFlows = Message$1<"a2a.v1.OAuthFlows"> & {
  /**
   * @generated from oneof a2a.v1.OAuthFlows.flow
   */
  flow: {
    /**
     * Configuration for the OAuth Authorization Code flow.
     *
     * @generated from field: a2a.v1.AuthorizationCodeOAuthFlow authorization_code = 1;
     */
    value: AuthorizationCodeOAuthFlow;
    case: "authorizationCode";
  } | {
    /**
     * Configuration for the OAuth Client Credentials flow.
     *
     * @generated from field: a2a.v1.ClientCredentialsOAuthFlow client_credentials = 2;
     */
    value: ClientCredentialsOAuthFlow;
    case: "clientCredentials";
  } | {
    /**
     * @generated from field: a2a.v1.ImplicitOAuthFlow implicit = 3 [deprecated = true];
     * @deprecated
     */
    value: ImplicitOAuthFlow;
    case: "implicit";
  } | {
    /**
     * @generated from field: a2a.v1.PasswordOAuthFlow password = 4 [deprecated = true];
     * @deprecated
     */
    value: PasswordOAuthFlow;
    case: "password";
  } | {
    /**
     * Configuration for the OAuth Device Code flow.
     *
     * @generated from field: a2a.v1.DeviceCodeOAuthFlow device_code = 5;
     */
    value: DeviceCodeOAuthFlow;
    case: "deviceCode";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message a2a.v1.OAuthFlows.
 * Use `create(OAuthFlowsSchema)` to create a new message.
 */
export const OAuthFlowsSchema: GenMessage<OAuthFlows> = /*@__PURE__*/
  messageDesc(file_a2a, 26);

/**
 * --8<-- [start:AuthorizationCodeOAuthFlow]
 * Defines configuration details for the OAuth 2.0 Authorization Code flow.
 *
 * @generated from message a2a.v1.AuthorizationCodeOAuthFlow
 */
export type AuthorizationCodeOAuthFlow = Message$1<"a2a.v1.AuthorizationCodeOAuthFlow"> & {
  /**
   * The authorization URL to be used for this flow.
   *
   * @generated from field: string authorization_url = 1;
   */
  authorizationUrl: string;

  /**
   * The token URL to be used for this flow.
   *
   * @generated from field: string token_url = 2;
   */
  tokenUrl: string;

  /**
   * The URL to be used for obtaining refresh tokens.
   *
   * @generated from field: string refresh_url = 3;
   */
  refreshUrl: string;

  /**
   * The available scopes for the OAuth2 security scheme.
   *
   * @generated from field: map<string, string> scopes = 4;
   */
  scopes: { [key: string]: string };

  /**
   * Indicates if PKCE (RFC 7636) is required for this flow.
   * PKCE should always be used for public clients and is recommended for all
   * clients.
   *
   * @generated from field: bool pkce_required = 5;
   */
  pkceRequired: boolean;
};

/**
 * Describes the message a2a.v1.AuthorizationCodeOAuthFlow.
 * Use `create(AuthorizationCodeOAuthFlowSchema)` to create a new message.
 */
export const AuthorizationCodeOAuthFlowSchema: GenMessage<AuthorizationCodeOAuthFlow> = /*@__PURE__*/
  messageDesc(file_a2a, 27);

/**
 * --8<-- [start:ClientCredentialsOAuthFlow]
 * Defines configuration details for the OAuth 2.0 Client Credentials flow.
 *
 * @generated from message a2a.v1.ClientCredentialsOAuthFlow
 */
export type ClientCredentialsOAuthFlow = Message$1<"a2a.v1.ClientCredentialsOAuthFlow"> & {
  /**
   * The token URL to be used for this flow.
   *
   * @generated from field: string token_url = 1;
   */
  tokenUrl: string;

  /**
   * The URL to be used for obtaining refresh tokens.
   *
   * @generated from field: string refresh_url = 2;
   */
  refreshUrl: string;

  /**
   * The available scopes for the OAuth2 security scheme.
   *
   * @generated from field: map<string, string> scopes = 3;
   */
  scopes: { [key: string]: string };
};

/**
 * Describes the message a2a.v1.ClientCredentialsOAuthFlow.
 * Use `create(ClientCredentialsOAuthFlowSchema)` to create a new message.
 */
export const ClientCredentialsOAuthFlowSchema: GenMessage<ClientCredentialsOAuthFlow> = /*@__PURE__*/
  messageDesc(file_a2a, 28);

/**
 * DEPRECATED
 *
 * @generated from message a2a.v1.ImplicitOAuthFlow
 */
export type ImplicitOAuthFlow = Message$1<"a2a.v1.ImplicitOAuthFlow"> & {
  /**
   * The authorization URL to be used for this flow. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS
   *
   * @generated from field: string authorization_url = 1;
   */
  authorizationUrl: string;

  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string refresh_url = 2;
   */
  refreshUrl: string;

  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   *
   * @generated from field: map<string, string> scopes = 3;
   */
  scopes: { [key: string]: string };
};

/**
 * Describes the message a2a.v1.ImplicitOAuthFlow.
 * Use `create(ImplicitOAuthFlowSchema)` to create a new message.
 */
export const ImplicitOAuthFlowSchema: GenMessage<ImplicitOAuthFlow> = /*@__PURE__*/
  messageDesc(file_a2a, 29);

/**
 * DEPRECATED
 *
 * @generated from message a2a.v1.PasswordOAuthFlow
 */
export type PasswordOAuthFlow = Message$1<"a2a.v1.PasswordOAuthFlow"> & {
  /**
   * The token URL to be used for this flow. This MUST be in the form of a URL.
   * The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string token_url = 1;
   */
  tokenUrl: string;

  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string refresh_url = 2;
   */
  refreshUrl: string;

  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   *
   * @generated from field: map<string, string> scopes = 3;
   */
  scopes: { [key: string]: string };
};

/**
 * Describes the message a2a.v1.PasswordOAuthFlow.
 * Use `create(PasswordOAuthFlowSchema)` to create a new message.
 */
export const PasswordOAuthFlowSchema: GenMessage<PasswordOAuthFlow> = /*@__PURE__*/
  messageDesc(file_a2a, 30);

/**
 * --8<-- [start:DeviceCodeOAuthFlow]
 * Defines configuration details for the OAuth 2.0 Device Code flow (RFC 8628).
 * This flow is designed for input-constrained devices such as IoT devices,
 * and CLI tools where the user authenticates on a separate device.
 *
 * @generated from message a2a.v1.DeviceCodeOAuthFlow
 */
export type DeviceCodeOAuthFlow = Message$1<"a2a.v1.DeviceCodeOAuthFlow"> & {
  /**
   * The device authorization endpoint URL.
   *
   * @generated from field: string device_authorization_url = 1;
   */
  deviceAuthorizationUrl: string;

  /**
   * The token URL to be used for this flow.
   *
   * @generated from field: string token_url = 2;
   */
  tokenUrl: string;

  /**
   * The URL to be used for obtaining refresh tokens.
   *
   * @generated from field: string refresh_url = 3;
   */
  refreshUrl: string;

  /**
   * The available scopes for the OAuth2 security scheme.
   *
   * @generated from field: map<string, string> scopes = 4;
   */
  scopes: { [key: string]: string };
};

/**
 * Describes the message a2a.v1.DeviceCodeOAuthFlow.
 * Use `create(DeviceCodeOAuthFlowSchema)` to create a new message.
 */
export const DeviceCodeOAuthFlowSchema: GenMessage<DeviceCodeOAuthFlow> = /*@__PURE__*/
  messageDesc(file_a2a, 31);

/**
 * /////////// Request Messages ///////////
 * --8<-- [start:SendMessageRequest]
 * Represents a request for the `SendMessage` method.
 *
 * @generated from message a2a.v1.SendMessageRequest
 */
export type SendMessageRequest = Message$1<"a2a.v1.SendMessageRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 4;
   */
  tenant: string;

  /**
   * The message to send to the agent.
   *
   * @generated from field: a2a.v1.Message message = 1;
   */
  message?: Message;

  /**
   * Configuration for the send request.
   *
   * @generated from field: a2a.v1.SendMessageConfiguration configuration = 2;
   */
  configuration?: SendMessageConfiguration;

  /**
   * A flexible key-value map for passing additional context or parameters.
   *
   * @generated from field: google.protobuf.Struct metadata = 3;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message a2a.v1.SendMessageRequest.
 * Use `create(SendMessageRequestSchema)` to create a new message.
 */
export const SendMessageRequestSchema: GenMessage<SendMessageRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 32);

/**
 * --8<-- [start:GetTaskRequest]
 * Represents a request for the `GetTask` method.
 *
 * @generated from message a2a.v1.GetTaskRequest
 */
export type GetTaskRequest = Message$1<"a2a.v1.GetTaskRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 3;
   */
  tenant: string;

  /**
   * The resource id of the task.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The maximum number of most recent messages from the task's history to
   * retrieve. An unset value means the client does not impose any limit. A
   * value of zero is a request to not include any messages. The server MUST NOT
   * return more messages than the provided value, but MAY apply a lower limit.
   *
   * @generated from field: optional int32 history_length = 2;
   */
  historyLength?: number;
};

/**
 * Describes the message a2a.v1.GetTaskRequest.
 * Use `create(GetTaskRequestSchema)` to create a new message.
 */
export const GetTaskRequestSchema: GenMessage<GetTaskRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 33);

/**
 * --8<-- [start:ListTasksRequest]
 * Parameters for listing tasks with optional filtering criteria.
 *
 * @generated from message a2a.v1.ListTasksRequest
 */
export type ListTasksRequest = Message$1<"a2a.v1.ListTasksRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 9;
   */
  tenant: string;

  /**
   * Filter tasks by context ID to get tasks from a specific conversation or
   * session.
   *
   * @generated from field: string context_id = 1;
   */
  contextId: string;

  /**
   * Filter tasks by their current status state.
   *
   * @generated from field: a2a.v1.TaskState status = 2;
   */
  status: TaskState;

  /**
   * Maximum number of tasks to return. Must be between 1 and 100.
   * Defaults to 50 if not specified.
   *
   * @generated from field: optional int32 page_size = 3;
   */
  pageSize?: number;

  /**
   * Token for pagination. Use the next_page_token from a previous
   * ListTasksResponse.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;

  /**
   * The maximum number of messages to include in each task's history.
   *
   * @generated from field: optional int32 history_length = 5;
   */
  historyLength?: number;

  /**
   * Filter tasks which have a status updated after the provided timestamp in
   * ISO 8601 format (e.g., "2023-10-27T10:00:00Z"). Only tasks with a status
   * timestamp time greater than or equal to this value will be returned.
   *
   * @generated from field: google.protobuf.Timestamp status_timestamp_after = 6;
   */
  statusTimestampAfter?: Timestamp;

  /**
   * Whether to include artifacts in the returned tasks.
   * Defaults to false to reduce payload size.
   *
   * @generated from field: optional bool include_artifacts = 7;
   */
  includeArtifacts?: boolean;
};

/**
 * Describes the message a2a.v1.ListTasksRequest.
 * Use `create(ListTasksRequestSchema)` to create a new message.
 */
export const ListTasksRequestSchema: GenMessage<ListTasksRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 34);

/**
 * --8<-- [start:ListTasksResponse]
 * Result object for tasks/list method containing an array of tasks and
 * pagination information.
 *
 * @generated from message a2a.v1.ListTasksResponse
 */
export type ListTasksResponse = Message$1<"a2a.v1.ListTasksResponse"> & {
  /**
   * Array of tasks matching the specified criteria.
   *
   * @generated from field: repeated a2a.v1.Task tasks = 1;
   */
  tasks: Task[];

  /**
   * Token for retrieving the next page. Empty string if no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * The size of page requested.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Total number of tasks available (before pagination).
   *
   * @generated from field: int32 total_size = 4;
   */
  totalSize: number;
};

/**
 * Describes the message a2a.v1.ListTasksResponse.
 * Use `create(ListTasksResponseSchema)` to create a new message.
 */
export const ListTasksResponseSchema: GenMessage<ListTasksResponse> = /*@__PURE__*/
  messageDesc(file_a2a, 35);

/**
 * --8<-- [start:CancelTaskRequest]
 * Represents a request for the `CancelTask` method.
 *
 * @generated from message a2a.v1.CancelTaskRequest
 */
export type CancelTaskRequest = Message$1<"a2a.v1.CancelTaskRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 2;
   */
  tenant: string;

  /**
   * The resource id of the task to cancel.
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message a2a.v1.CancelTaskRequest.
 * Use `create(CancelTaskRequestSchema)` to create a new message.
 */
export const CancelTaskRequestSchema: GenMessage<CancelTaskRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 36);

/**
 * --8<-- [start:GetTaskPushNotificationConfigRequest]
 *
 * @generated from message a2a.v1.GetTaskPushNotificationConfigRequest
 */
export type GetTaskPushNotificationConfigRequest = Message$1<"a2a.v1.GetTaskPushNotificationConfigRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 2;
   */
  tenant: string;

  /**
   * The parent task resource id.
   *
   * @generated from field: string task_id = 3;
   */
  taskId: string;

  /**
   * The resource id of the config to retrieve.
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message a2a.v1.GetTaskPushNotificationConfigRequest.
 * Use `create(GetTaskPushNotificationConfigRequestSchema)` to create a new message.
 */
export const GetTaskPushNotificationConfigRequestSchema: GenMessage<GetTaskPushNotificationConfigRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 37);

/**
 * --8<-- [start:DeleteTaskPushNotificationConfigRequest]
 * Represents a request for the `DeleteTaskPushNotificationConfig` method.
 *
 * @generated from message a2a.v1.DeleteTaskPushNotificationConfigRequest
 */
export type DeleteTaskPushNotificationConfigRequest = Message$1<"a2a.v1.DeleteTaskPushNotificationConfigRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 2;
   */
  tenant: string;

  /**
   * The parent task resource id.
   *
   * @generated from field: string task_id = 3;
   */
  taskId: string;

  /**
   * The resource id of the config to delete.
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message a2a.v1.DeleteTaskPushNotificationConfigRequest.
 * Use `create(DeleteTaskPushNotificationConfigRequestSchema)` to create a new message.
 */
export const DeleteTaskPushNotificationConfigRequestSchema: GenMessage<DeleteTaskPushNotificationConfigRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 38);

/**
 * --8<-- [start:CreateTaskPushNotificationConfigRequest]
 * Represents a request for the `CreateTaskPushNotificationConfig` method.
 *
 * @generated from message a2a.v1.CreateTaskPushNotificationConfigRequest
 */
export type CreateTaskPushNotificationConfigRequest = Message$1<"a2a.v1.CreateTaskPushNotificationConfigRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 4;
   */
  tenant: string;

  /**
   * The parent task resource id.
   *
   * @generated from field: string task_id = 1;
   */
  taskId: string;

  /**
   * The ID for the new config.
   *
   * @generated from field: string config_id = 2;
   */
  configId: string;

  /**
   * The configuration to create.
   *
   * @generated from field: a2a.v1.PushNotificationConfig config = 5;
   */
  config?: PushNotificationConfig;
};

/**
 * Describes the message a2a.v1.CreateTaskPushNotificationConfigRequest.
 * Use `create(CreateTaskPushNotificationConfigRequestSchema)` to create a new message.
 */
export const CreateTaskPushNotificationConfigRequestSchema: GenMessage<CreateTaskPushNotificationConfigRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 39);

/**
 * --8<-- [start:SubscribeToTaskRequest]
 *
 * @generated from message a2a.v1.SubscribeToTaskRequest
 */
export type SubscribeToTaskRequest = Message$1<"a2a.v1.SubscribeToTaskRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 2;
   */
  tenant: string;

  /**
   * The resource id of the task to subscribe to.
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message a2a.v1.SubscribeToTaskRequest.
 * Use `create(SubscribeToTaskRequestSchema)` to create a new message.
 */
export const SubscribeToTaskRequestSchema: GenMessage<SubscribeToTaskRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 40);

/**
 * --8<-- [start:ListTaskPushNotificationConfigRequest]
 *
 * @generated from message a2a.v1.ListTaskPushNotificationConfigRequest
 */
export type ListTaskPushNotificationConfigRequest = Message$1<"a2a.v1.ListTaskPushNotificationConfigRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 4;
   */
  tenant: string;

  /**
   * The parent task resource id.
   *
   * @generated from field: string task_id = 1;
   */
  taskId: string;

  /**
   * The maximum number of configurations to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token received from a previous ListTaskPushNotificationConfigRequest
   * call.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message a2a.v1.ListTaskPushNotificationConfigRequest.
 * Use `create(ListTaskPushNotificationConfigRequestSchema)` to create a new message.
 */
export const ListTaskPushNotificationConfigRequestSchema: GenMessage<ListTaskPushNotificationConfigRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 41);

/**
 * --8<-- [start:GetExtendedAgentCardRequest]
 *
 * @generated from message a2a.v1.GetExtendedAgentCardRequest
 */
export type GetExtendedAgentCardRequest = Message$1<"a2a.v1.GetExtendedAgentCardRequest"> & {
  /**
   * Optional tenant, provided as a path parameter.
   *
   * @generated from field: string tenant = 1;
   */
  tenant: string;
};

/**
 * Describes the message a2a.v1.GetExtendedAgentCardRequest.
 * Use `create(GetExtendedAgentCardRequestSchema)` to create a new message.
 */
export const GetExtendedAgentCardRequestSchema: GenMessage<GetExtendedAgentCardRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 42);

/**
 * ////// Response Messages ///////////
 * --8<-- [start:SendMessageResponse]
 *
 * @generated from message a2a.v1.SendMessageResponse
 */
export type SendMessageResponse = Message$1<"a2a.v1.SendMessageResponse"> & {
  /**
   * @generated from oneof a2a.v1.SendMessageResponse.payload
   */
  payload: {
    /**
     * @generated from field: a2a.v1.Task task = 1;
     */
    value: Task;
    case: "task";
  } | {
    /**
     * @generated from field: a2a.v1.Message message = 2;
     */
    value: Message;
    case: "message";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message a2a.v1.SendMessageResponse.
 * Use `create(SendMessageResponseSchema)` to create a new message.
 */
export const SendMessageResponseSchema: GenMessage<SendMessageResponse> = /*@__PURE__*/
  messageDesc(file_a2a, 43);

/**
 * --8<-- [start:StreamResponse]
 * A wrapper object used in streaming operations to encapsulate different types
 * of response data.
 *
 * @generated from message a2a.v1.StreamResponse
 */
export type StreamResponse = Message$1<"a2a.v1.StreamResponse"> & {
  /**
   * @generated from oneof a2a.v1.StreamResponse.payload
   */
  payload: {
    /**
     * A Task object containing the current state of the task.
     *
     * @generated from field: a2a.v1.Task task = 1;
     */
    value: Task;
    case: "task";
  } | {
    /**
     * A Message object containing a message from the agent.
     *
     * @generated from field: a2a.v1.Message message = 2;
     */
    value: Message;
    case: "message";
  } | {
    /**
     * An event indicating a task status update.
     *
     * @generated from field: a2a.v1.TaskStatusUpdateEvent status_update = 3;
     */
    value: TaskStatusUpdateEvent;
    case: "statusUpdate";
  } | {
    /**
     * An event indicating a task artifact update.
     *
     * @generated from field: a2a.v1.TaskArtifactUpdateEvent artifact_update = 4;
     */
    value: TaskArtifactUpdateEvent;
    case: "artifactUpdate";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message a2a.v1.StreamResponse.
 * Use `create(StreamResponseSchema)` to create a new message.
 */
export const StreamResponseSchema: GenMessage<StreamResponse> = /*@__PURE__*/
  messageDesc(file_a2a, 44);

/**
 * --8<-- [start:ListTaskPushNotificationConfigResponse]
 * Represents a successful response for the `ListTaskPushNotificationConfig`
 * method.
 *
 * @generated from message a2a.v1.ListTaskPushNotificationConfigResponse
 */
export type ListTaskPushNotificationConfigResponse = Message$1<"a2a.v1.ListTaskPushNotificationConfigResponse"> & {
  /**
   * The list of push notification configurations.
   *
   * @generated from field: repeated a2a.v1.TaskPushNotificationConfig configs = 1;
   */
  configs: TaskPushNotificationConfig[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message a2a.v1.ListTaskPushNotificationConfigResponse.
 * Use `create(ListTaskPushNotificationConfigResponseSchema)` to create a new message.
 */
export const ListTaskPushNotificationConfigResponseSchema: GenMessage<ListTaskPushNotificationConfigResponse> = /*@__PURE__*/
  messageDesc(file_a2a, 45);

/**
 * --8<-- [start:TaskState]
 * Defines the possible lifecycle states of a Task.
 *
 * @generated from enum a2a.v1.TaskState
 */
export enum TaskState {
  /**
   * The task is in an unknown or indeterminate state.
   *
   * @generated from enum value: TASK_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Represents the status that acknowledges a task is created.
   *
   * @generated from enum value: TASK_STATE_SUBMITTED = 1;
   */
  SUBMITTED = 1,

  /**
   * Represents the status that a task is actively being processed.
   *
   * @generated from enum value: TASK_STATE_WORKING = 2;
   */
  WORKING = 2,

  /**
   * Represents the status a task is finished. This is a terminal state.
   *
   * @generated from enum value: TASK_STATE_COMPLETED = 3;
   */
  COMPLETED = 3,

  /**
   * Represents the status a task is done but failed. This is a terminal state.
   *
   * @generated from enum value: TASK_STATE_FAILED = 4;
   */
  FAILED = 4,

  /**
   * Represents the status a task was canceled before it finished.
   * This is a terminal state.
   *
   * @generated from enum value: TASK_STATE_CANCELED = 5;
   */
  CANCELED = 5,

  /**
   * Represents the status that the task requires information to complete.
   * This is an interrupted state.
   *
   * @generated from enum value: TASK_STATE_INPUT_REQUIRED = 6;
   */
  INPUT_REQUIRED = 6,

  /**
   * Represents the status that the agent has decided to not perform the task.
   * This may be done during initial task creation or later once an agent
   * has determined it can't or won't proceed. This is a terminal state.
   *
   * @generated from enum value: TASK_STATE_REJECTED = 7;
   */
  REJECTED = 7,

  /**
   * Represents the state that some authentication is needed from the upstream
   * client. This is an interrupted state. Authentication is expected to come
   * out-of-band.
   *
   * @generated from enum value: TASK_STATE_AUTH_REQUIRED = 8;
   */
  AUTH_REQUIRED = 8,
}

/**
 * Describes the enum a2a.v1.TaskState.
 */
export const TaskStateSchema: GenEnum<TaskState> = /*@__PURE__*/
  enumDesc(file_a2a, 0);

/**
 * --8<-- [start:Role]
 * Defines the sender of a message in A2A protocol communication.
 *
 * @generated from enum a2a.v1.Role
 */
export enum Role {
  /**
   * @generated from enum value: ROLE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * USER role refers to communication from the client to the server.
   *
   * @generated from enum value: ROLE_USER = 1;
   */
  USER = 1,

  /**
   * AGENT role refers to communication from the server to the client.
   *
   * @generated from enum value: ROLE_AGENT = 2;
   */
  AGENT = 2,
}

/**
 * Describes the enum a2a.v1.Role.
 */
export const RoleSchema: GenEnum<Role> = /*@__PURE__*/
  enumDesc(file_a2a, 1);

/**
 * A2AService defines the operations of the A2A protocol.
 *
 * @generated from service a2a.v1.A2AService
 */
export const A2AService: GenService<{
  /**
   * Send a message to the agent.
   *
   * @generated from rpc a2a.v1.A2AService.SendMessage
   */
  sendMessage: {
    methodKind: "unary";
    input: typeof SendMessageRequestSchema;
    output: typeof SendMessageResponseSchema;
  },
  /**
   * SendStreamingMessage is a streaming version of SendMessage.
   *
   * @generated from rpc a2a.v1.A2AService.SendStreamingMessage
   */
  sendStreamingMessage: {
    methodKind: "server_streaming";
    input: typeof SendMessageRequestSchema;
    output: typeof StreamResponseSchema;
  },
  /**
   * Get the current state of a task from the agent.
   *
   * @generated from rpc a2a.v1.A2AService.GetTask
   */
  getTask: {
    methodKind: "unary";
    input: typeof GetTaskRequestSchema;
    output: typeof TaskSchema;
  },
  /**
   * List tasks with optional filtering and pagination.
   *
   * @generated from rpc a2a.v1.A2AService.ListTasks
   */
  listTasks: {
    methodKind: "unary";
    input: typeof ListTasksRequestSchema;
    output: typeof ListTasksResponseSchema;
  },
  /**
   * Cancel a task.
   *
   * @generated from rpc a2a.v1.A2AService.CancelTask
   */
  cancelTask: {
    methodKind: "unary";
    input: typeof CancelTaskRequestSchema;
    output: typeof TaskSchema;
  },
  /**
   * SubscribeToTask allows subscribing to task updates for tasks not in
   * terminal state. Returns UnsupportedOperationError if task is in terminal
   * state (completed, failed, canceled, rejected).
   *
   * @generated from rpc a2a.v1.A2AService.SubscribeToTask
   */
  subscribeToTask: {
    methodKind: "server_streaming";
    input: typeof SubscribeToTaskRequestSchema;
    output: typeof StreamResponseSchema;
  },
  /**
   * Create a push notification config for a task.
   *
   * @generated from rpc a2a.v1.A2AService.CreateTaskPushNotificationConfig
   */
  createTaskPushNotificationConfig: {
    methodKind: "unary";
    input: typeof CreateTaskPushNotificationConfigRequestSchema;
    output: typeof TaskPushNotificationConfigSchema;
  },
  /**
   * Get a push notification config for a task.
   *
   * @generated from rpc a2a.v1.A2AService.GetTaskPushNotificationConfig
   */
  getTaskPushNotificationConfig: {
    methodKind: "unary";
    input: typeof GetTaskPushNotificationConfigRequestSchema;
    output: typeof TaskPushNotificationConfigSchema;
  },
  /**
   * Get a list of push notifications configured for a task.
   *
   * @generated from rpc a2a.v1.A2AService.ListTaskPushNotificationConfig
   */
  listTaskPushNotificationConfig: {
    methodKind: "unary";
    input: typeof ListTaskPushNotificationConfigRequestSchema;
    output: typeof ListTaskPushNotificationConfigResponseSchema;
  },
  /**
   * GetExtendedAgentCard returns the extended agent card for authenticated
   * agents.
   *
   * @generated from rpc a2a.v1.A2AService.GetExtendedAgentCard
   */
  getExtendedAgentCard: {
    methodKind: "unary";
    input: typeof GetExtendedAgentCardRequestSchema;
    output: typeof AgentCardSchema;
  },
  /**
   * Delete a push notification config for a task.
   *
   * @generated from rpc a2a.v1.A2AService.DeleteTaskPushNotificationConfig
   */
  deleteTaskPushNotificationConfig: {
    methodKind: "unary";
    input: typeof DeleteTaskPushNotificationConfigRequestSchema;
    output: typeof EmptySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_a2a, 0);

