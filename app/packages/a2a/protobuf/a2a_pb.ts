// Older protoc compilers don't understand edition yet.

// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file a2a.proto (package a2a.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_google_api_annotations } from "./google/api/annotations_pb";
import { file_google_api_client } from "./google/api/client_pb";
import { file_google_api_field_behavior } from "./google/api/field_behavior_pb";
import type { EmptySchema, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { JsonObject, Message as Message$1 } from "@bufbuild/protobuf";

/**
 * Describes the file a2a.proto.
 */
export const file_a2a: GenFile = /*@__PURE__*/
  fileDesc("CglhMmEucHJvdG8SBmEyYS52MSKeAQoYU2VuZE1lc3NhZ2VDb25maWd1cmF0aW9uEh0KFWFjY2VwdGVkX291dHB1dF9tb2RlcxgBIAMoCRI5ChFwdXNoX25vdGlmaWNhdGlvbhgCIAEoCzIeLmEyYS52MS5QdXNoTm90aWZpY2F0aW9uQ29uZmlnEhYKDmhpc3RvcnlfbGVuZ3RoGAMgASgFEhAKCGJsb2NraW5nGAQgASgIIrwBCgRUYXNrEgoKAmlkGAEgASgJEhIKCmNvbnRleHRfaWQYAiABKAkSIgoGc3RhdHVzGAMgASgLMhIuYTJhLnYxLlRhc2tTdGF0dXMSIwoJYXJ0aWZhY3RzGAQgAygLMhAuYTJhLnYxLkFydGlmYWN0EiAKB2hpc3RvcnkYBSADKAsyDy5hMmEudjEuTWVzc2FnZRIpCghtZXRhZGF0YRgGIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QihwEKClRhc2tTdGF0dXMSIAoFc3RhdGUYASABKA4yES5hMmEudjEuVGFza1N0YXRlEigKBnVwZGF0ZRgCIAEoCzIPLmEyYS52MS5NZXNzYWdlUgdtZXNzYWdlEi0KCXRpbWVzdGFtcBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAijQEKBFBhcnQSDgoEdGV4dBgBIAEoCUgAEiAKBGZpbGUYAiABKAsyEC5hMmEudjEuRmlsZVBhcnRIABIgCgRkYXRhGAMgASgLMhAuYTJhLnYxLkRhdGFQYXJ0SAASKQoIbWV0YWRhdGEYBCABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0QgYKBHBhcnQiZwoIRmlsZVBhcnQSFwoNZmlsZV93aXRoX3VyaRgBIAEoCUgAEhkKD2ZpbGVfd2l0aF9ieXRlcxgCIAEoDEgAEhEKCW1pbWVfdHlwZRgDIAEoCRIMCgRuYW1lGAQgASgJQgYKBGZpbGUiMQoIRGF0YVBhcnQSJQoEZGF0YRgBIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3Qi1gEKB01lc3NhZ2USEgoKbWVzc2FnZV9pZBgBIAEoCRISCgpjb250ZXh0X2lkGAIgASgJEg8KB3Rhc2tfaWQYAyABKAkSGgoEcm9sZRgEIAEoDjIMLmEyYS52MS5Sb2xlEhsKBXBhcnRzGAUgAygLMgwuYTJhLnYxLlBhcnQSKQoIbWV0YWRhdGEYBiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0EhIKCmV4dGVuc2lvbnMYByADKAkSGgoScmVmZXJlbmNlX3Rhc2tfaWRzGAggAygJIp4BCghBcnRpZmFjdBITCgthcnRpZmFjdF9pZBgBIAEoCRIMCgRuYW1lGAMgASgJEhMKC2Rlc2NyaXB0aW9uGAQgASgJEhsKBXBhcnRzGAUgAygLMgwuYTJhLnYxLlBhcnQSKQoIbWV0YWRhdGEYBiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0EhIKCmV4dGVuc2lvbnMYByADKAkimgEKFVRhc2tTdGF0dXNVcGRhdGVFdmVudBIPCgd0YXNrX2lkGAEgASgJEhIKCmNvbnRleHRfaWQYAiABKAkSIgoGc3RhdHVzGAMgASgLMhIuYTJhLnYxLlRhc2tTdGF0dXMSDQoFZmluYWwYBCABKAgSKQoIbWV0YWRhdGEYBSABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0IrEBChdUYXNrQXJ0aWZhY3RVcGRhdGVFdmVudBIPCgd0YXNrX2lkGAEgASgJEhIKCmNvbnRleHRfaWQYAiABKAkSIgoIYXJ0aWZhY3QYAyABKAsyEC5hMmEudjEuQXJ0aWZhY3QSDgoGYXBwZW5kGAQgASgIEhIKCmxhc3RfY2h1bmsYBSABKAgSKQoIbWV0YWRhdGEYBiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0InQKFlB1c2hOb3RpZmljYXRpb25Db25maWcSCgoCaWQYASABKAkSCwoDdXJsGAIgASgJEg0KBXRva2VuGAMgASgJEjIKDmF1dGhlbnRpY2F0aW9uGAQgASgLMhouYTJhLnYxLkF1dGhlbnRpY2F0aW9uSW5mbyI6ChJBdXRoZW50aWNhdGlvbkluZm8SDwoHc2NoZW1lcxgBIAMoCRITCgtjcmVkZW50aWFscxgCIAEoCSIwCg5BZ2VudEludGVyZmFjZRILCgN1cmwYASABKAkSEQoJdHJhbnNwb3J0GAIgASgJIrQFCglBZ2VudENhcmQSGAoQcHJvdG9jb2xfdmVyc2lvbhgQIAEoCRIMCgRuYW1lGAEgASgJEhMKC2Rlc2NyaXB0aW9uGAIgASgJEgsKA3VybBgDIAEoCRIbChNwcmVmZXJyZWRfdHJhbnNwb3J0GA4gASgJEjUKFWFkZGl0aW9uYWxfaW50ZXJmYWNlcxgPIAMoCzIWLmEyYS52MS5BZ2VudEludGVyZmFjZRInCghwcm92aWRlchgEIAEoCzIVLmEyYS52MS5BZ2VudFByb3ZpZGVyEg8KB3ZlcnNpb24YBSABKAkSGQoRZG9jdW1lbnRhdGlvbl91cmwYBiABKAkSLwoMY2FwYWJpbGl0aWVzGAcgASgLMhkuYTJhLnYxLkFnZW50Q2FwYWJpbGl0aWVzEkAKEHNlY3VyaXR5X3NjaGVtZXMYCCADKAsyJi5hMmEudjEuQWdlbnRDYXJkLlNlY3VyaXR5U2NoZW1lc0VudHJ5EiIKCHNlY3VyaXR5GAkgAygLMhAuYTJhLnYxLlNlY3VyaXR5EhsKE2RlZmF1bHRfaW5wdXRfbW9kZXMYCiADKAkSHAoUZGVmYXVsdF9vdXRwdXRfbW9kZXMYCyADKAkSIgoGc2tpbGxzGAwgAygLMhIuYTJhLnYxLkFnZW50U2tpbGwSLAokc3VwcG9ydHNfYXV0aGVudGljYXRlZF9leHRlbmRlZF9jYXJkGA0gASgIEi4KCnNpZ25hdHVyZXMYESADKAsyGi5hMmEudjEuQWdlbnRDYXJkU2lnbmF0dXJlEhAKCGljb25fdXJsGBIgASgJGk4KFFNlY3VyaXR5U2NoZW1lc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmEyYS52MS5TZWN1cml0eVNjaGVtZToCOAEiMgoNQWdlbnRQcm92aWRlchILCgN1cmwYASABKAkSFAoMb3JnYW5pemF0aW9uGAIgASgJIpABChFBZ2VudENhcGFiaWxpdGllcxIRCglzdHJlYW1pbmcYASABKAgSGgoScHVzaF9ub3RpZmljYXRpb25zGAIgASgIEioKCmV4dGVuc2lvbnMYAyADKAsyFi5hMmEudjEuQWdlbnRFeHRlbnNpb24SIAoYc3RhdGVfdHJhbnNpdGlvbl9oaXN0b3J5GAQgASgIIm0KDkFnZW50RXh0ZW5zaW9uEgsKA3VyaRgBIAEoCRITCgtkZXNjcmlwdGlvbhgCIAEoCRIQCghyZXF1aXJlZBgDIAEoCBInCgZwYXJhbXMYBCABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0IqoBCgpBZ2VudFNraWxsEgoKAmlkGAEgASgJEgwKBG5hbWUYAiABKAkSEwoLZGVzY3JpcHRpb24YAyABKAkSDAoEdGFncxgEIAMoCRIQCghleGFtcGxlcxgFIAMoCRITCgtpbnB1dF9tb2RlcxgGIAMoCRIUCgxvdXRwdXRfbW9kZXMYByADKAkSIgoIc2VjdXJpdHkYCCADKAsyEC5hMmEudjEuU2VjdXJpdHkibQoSQWdlbnRDYXJkU2lnbmF0dXJlEhYKCXByb3RlY3RlZBgBIAEoCUID4EECEhYKCXNpZ25hdHVyZRgCIAEoCUID4EECEicKBmhlYWRlchgDIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QibAoaVGFza1B1c2hOb3RpZmljYXRpb25Db25maWcSDAoEbmFtZRgBIAEoCRJAChhwdXNoX25vdGlmaWNhdGlvbl9jb25maWcYAiABKAsyHi5hMmEudjEuUHVzaE5vdGlmaWNhdGlvbkNvbmZpZyIaCgpTdHJpbmdMaXN0EgwKBGxpc3QYASADKAkifgoIU2VjdXJpdHkSLgoHc2NoZW1lcxgBIAMoCzIdLmEyYS52MS5TZWN1cml0eS5TY2hlbWVzRW50cnkaQgoMU2NoZW1lc0VudHJ5EgsKA2tleRgBIAEoCRIhCgV2YWx1ZRgCIAEoCzISLmEyYS52MS5TdHJpbmdMaXN0OgI4ASLxAgoOU2VjdXJpdHlTY2hlbWUSPwoXYXBpX2tleV9zZWN1cml0eV9zY2hlbWUYASABKAsyHC5hMmEudjEuQVBJS2V5U2VjdXJpdHlTY2hlbWVIABJDChlodHRwX2F1dGhfc2VjdXJpdHlfc2NoZW1lGAIgASgLMh4uYTJhLnYxLkhUVFBBdXRoU2VjdXJpdHlTY2hlbWVIABI+ChZvYXV0aDJfc2VjdXJpdHlfc2NoZW1lGAMgASgLMhwuYTJhLnYxLk9BdXRoMlNlY3VyaXR5U2NoZW1lSAASTgofb3Blbl9pZF9jb25uZWN0X3NlY3VyaXR5X3NjaGVtZRgEIAEoCzIjLmEyYS52MS5PcGVuSWRDb25uZWN0U2VjdXJpdHlTY2hlbWVIABI/ChRtdGxzX3NlY3VyaXR5X3NjaGVtZRgFIAEoCzIfLmEyYS52MS5NdXR1YWxUbHNTZWN1cml0eVNjaGVtZUgAQggKBnNjaGVtZSJLChRBUElLZXlTZWN1cml0eVNjaGVtZRITCgtkZXNjcmlwdGlvbhgBIAEoCRIQCghsb2NhdGlvbhgCIAEoCRIMCgRuYW1lGAMgASgJIlQKFkhUVFBBdXRoU2VjdXJpdHlTY2hlbWUSEwoLZGVzY3JpcHRpb24YASABKAkSDgoGc2NoZW1lGAIgASgJEhUKDWJlYXJlcl9mb3JtYXQYAyABKAkiawoUT0F1dGgyU2VjdXJpdHlTY2hlbWUSEwoLZGVzY3JpcHRpb24YASABKAkSIQoFZmxvd3MYAiABKAsyEi5hMmEudjEuT0F1dGhGbG93cxIbChNvYXV0aDJfbWV0YWRhdGFfdXJsGAMgASgJIk8KG09wZW5JZENvbm5lY3RTZWN1cml0eVNjaGVtZRITCgtkZXNjcmlwdGlvbhgBIAEoCRIbChNvcGVuX2lkX2Nvbm5lY3RfdXJsGAIgASgJIi4KF011dHVhbFRsc1NlY3VyaXR5U2NoZW1lEhMKC2Rlc2NyaXB0aW9uGAEgASgJIvYBCgpPQXV0aEZsb3dzEkAKEmF1dGhvcml6YXRpb25fY29kZRgBIAEoCzIiLmEyYS52MS5BdXRob3JpemF0aW9uQ29kZU9BdXRoRmxvd0gAEkAKEmNsaWVudF9jcmVkZW50aWFscxgCIAEoCzIiLmEyYS52MS5DbGllbnRDcmVkZW50aWFsc09BdXRoRmxvd0gAEi0KCGltcGxpY2l0GAMgASgLMhkuYTJhLnYxLkltcGxpY2l0T0F1dGhGbG93SAASLQoIcGFzc3dvcmQYBCABKAsyGS5hMmEudjEuUGFzc3dvcmRPQXV0aEZsb3dIAEIGCgRmbG93Is4BChpBdXRob3JpemF0aW9uQ29kZU9BdXRoRmxvdxIZChFhdXRob3JpemF0aW9uX3VybBgBIAEoCRIRCgl0b2tlbl91cmwYAiABKAkSEwoLcmVmcmVzaF91cmwYAyABKAkSPgoGc2NvcGVzGAQgAygLMi4uYTJhLnYxLkF1dGhvcml6YXRpb25Db2RlT0F1dGhGbG93LlNjb3Blc0VudHJ5Gi0KC1Njb3Blc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiswEKGkNsaWVudENyZWRlbnRpYWxzT0F1dGhGbG93EhEKCXRva2VuX3VybBgBIAEoCRITCgtyZWZyZXNoX3VybBgCIAEoCRI+CgZzY29wZXMYAyADKAsyLi5hMmEudjEuQ2xpZW50Q3JlZGVudGlhbHNPQXV0aEZsb3cuU2NvcGVzRW50cnkaLQoLU2NvcGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKpAQoRSW1wbGljaXRPQXV0aEZsb3cSGQoRYXV0aG9yaXphdGlvbl91cmwYASABKAkSEwoLcmVmcmVzaF91cmwYAiABKAkSNQoGc2NvcGVzGAMgAygLMiUuYTJhLnYxLkltcGxpY2l0T0F1dGhGbG93LlNjb3Blc0VudHJ5Gi0KC1Njb3Blc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEioQEKEVBhc3N3b3JkT0F1dGhGbG93EhEKCXRva2VuX3VybBgBIAEoCRITCgtyZWZyZXNoX3VybBgCIAEoCRI1CgZzY29wZXMYAyADKAsyJS5hMmEudjEuUGFzc3dvcmRPQXV0aEZsb3cuU2NvcGVzRW50cnkaLQoLU2NvcGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKoAQoSU2VuZE1lc3NhZ2VSZXF1ZXN0Ei4KB3JlcXVlc3QYASABKAsyDy5hMmEudjEuTWVzc2FnZUID4EECUgdtZXNzYWdlEjcKDWNvbmZpZ3VyYXRpb24YAiABKAsyIC5hMmEudjEuU2VuZE1lc3NhZ2VDb25maWd1cmF0aW9uEikKCG1ldGFkYXRhGAMgASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCI7Cg5HZXRUYXNrUmVxdWVzdBIRCgRuYW1lGAEgASgJQgPgQQISFgoOaGlzdG9yeV9sZW5ndGgYAiABKAUi2gEKEExpc3RUYXNrc1JlcXVlc3QSEgoKY29udGV4dF9pZBgBIAEoCRIhCgZzdGF0dXMYAiABKA4yES5hMmEudjEuVGFza1N0YXRlEhEKCXBhZ2Vfc2l6ZRgDIAEoBRISCgpwYWdlX3Rva2VuGAQgASgJEhYKDmhpc3RvcnlfbGVuZ3RoGAUgASgFEjUKEWxhc3RfdXBkYXRlZF90aW1lGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIZChFpbmNsdWRlX2FydGlmYWN0cxgHIAEoCCJdChFMaXN0VGFza3NSZXNwb25zZRIbCgV0YXNrcxgBIAMoCzIMLmEyYS52MS5UYXNrEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCRISCgp0b3RhbF9zaXplGAMgASgFIiEKEUNhbmNlbFRhc2tSZXF1ZXN0EgwKBG5hbWUYASABKAkiNAokR2V0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWdSZXF1ZXN0EgwKBG5hbWUYASABKAkiNwonRGVsZXRlVGFza1B1c2hOb3RpZmljYXRpb25Db25maWdSZXF1ZXN0EgwKBG5hbWUYASABKAkijwEKJ0NyZWF0ZVRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVxdWVzdBITCgZwYXJlbnQYASABKAlCA+BBAhIWCgljb25maWdfaWQYAiABKAlCA+BBAhI3CgZjb25maWcYAyABKAsyIi5hMmEudjEuVGFza1B1c2hOb3RpZmljYXRpb25Db25maWdCA+BBAiInChdUYXNrU3Vic2NyaXB0aW9uUmVxdWVzdBIMCgRuYW1lGAEgASgJIl4KJUxpc3RUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1JlcXVlc3QSDgoGcGFyZW50GAEgASgJEhEKCXBhZ2Vfc2l6ZRgCIAEoBRISCgpwYWdlX3Rva2VuGAMgASgJIhUKE0dldEFnZW50Q2FyZFJlcXVlc3QiZwoTU2VuZE1lc3NhZ2VSZXNwb25zZRIcCgR0YXNrGAEgASgLMgwuYTJhLnYxLlRhc2tIABInCgNtc2cYAiABKAsyDy5hMmEudjEuTWVzc2FnZUgAUgdtZXNzYWdlQgkKB3BheWxvYWQi1gEKDlN0cmVhbVJlc3BvbnNlEhwKBHRhc2sYASABKAsyDC5hMmEudjEuVGFza0gAEicKA21zZxgCIAEoCzIPLmEyYS52MS5NZXNzYWdlSABSB21lc3NhZ2USNgoNc3RhdHVzX3VwZGF0ZRgDIAEoCzIdLmEyYS52MS5UYXNrU3RhdHVzVXBkYXRlRXZlbnRIABI6Cg9hcnRpZmFjdF91cGRhdGUYBCABKAsyHy5hMmEudjEuVGFza0FydGlmYWN0VXBkYXRlRXZlbnRIAEIJCgdwYXlsb2FkInYKJkxpc3RUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1Jlc3BvbnNlEjMKB2NvbmZpZ3MYASADKAsyIi5hMmEudjEuVGFza1B1c2hOb3RpZmljYXRpb25Db25maWcSFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJKvoBCglUYXNrU3RhdGUSGgoWVEFTS19TVEFURV9VTlNQRUNJRklFRBAAEhgKFFRBU0tfU1RBVEVfU1VCTUlUVEVEEAESFgoSVEFTS19TVEFURV9XT1JLSU5HEAISGAoUVEFTS19TVEFURV9DT01QTEVURUQQAxIVChFUQVNLX1NUQVRFX0ZBSUxFRBAEEhgKFFRBU0tfU1RBVEVfQ0FOQ0VMTEVEEAUSHQoZVEFTS19TVEFURV9JTlBVVF9SRVFVSVJFRBAGEhcKE1RBU0tfU1RBVEVfUkVKRUNURUQQBxIcChhUQVNLX1NUQVRFX0FVVEhfUkVRVUlSRUQQCCo7CgRSb2xlEhQKEFJPTEVfVU5TUEVDSUZJRUQQABINCglST0xFX1VTRVIQARIOCgpST0xFX0FHRU5UEAIykAsKCkEyQVNlcnZpY2USYwoLU2VuZE1lc3NhZ2USGi5hMmEudjEuU2VuZE1lc3NhZ2VSZXF1ZXN0GhsuYTJhLnYxLlNlbmRNZXNzYWdlUmVzcG9uc2UiG4LT5JMCFToBKiIQL3YxL21lc3NhZ2U6c2VuZBJrChRTZW5kU3RyZWFtaW5nTWVzc2FnZRIaLmEyYS52MS5TZW5kTWVzc2FnZVJlcXVlc3QaFi5hMmEudjEuU3RyZWFtUmVzcG9uc2UiHYLT5JMCFzoBKiISL3YxL21lc3NhZ2U6c3RyZWFtMAESUgoHR2V0VGFzaxIWLmEyYS52MS5HZXRUYXNrUmVxdWVzdBoMLmEyYS52MS5UYXNrIiHaQQRuYW1lgtPkkwIUEhIvdjEve25hbWU9dGFza3MvKn0SUwoJTGlzdFRhc2tzEhguYTJhLnYxLkxpc3RUYXNrc1JlcXVlc3QaGS5hMmEudjEuTGlzdFRhc2tzUmVzcG9uc2UiEYLT5JMCCxIJL3YxL3Rhc2tzElsKCkNhbmNlbFRhc2sSGS5hMmEudjEuQ2FuY2VsVGFza1JlcXVlc3QaDC5hMmEudjEuVGFzayIkgtPkkwIeOgEqIhkvdjEve25hbWU9dGFza3MvKn06Y2FuY2VsEnMKEFRhc2tTdWJzY3JpcHRpb24SHy5hMmEudjEuVGFza1N1YnNjcmlwdGlvblJlcXVlc3QaFi5hMmEudjEuU3RyZWFtUmVzcG9uc2UiJILT5JMCHhIcL3YxL3tuYW1lPXRhc2tzLyp9OnN1YnNjcmliZTABEsUBCiBDcmVhdGVUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZxIvLmEyYS52MS5DcmVhdGVUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1JlcXVlc3QaIi5hMmEudjEuVGFza1B1c2hOb3RpZmljYXRpb25Db25maWciTNpBDXBhcmVudCxjb25maWeC0+STAjY6BmNvbmZpZyIsL3YxL3twYXJlbnQ9dGFza3MvKi9wdXNoTm90aWZpY2F0aW9uQ29uZmlnc30SrgEKHUdldFRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnEiwuYTJhLnYxLkdldFRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVxdWVzdBoiLmEyYS52MS5UYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZyI72kEEbmFtZYLT5JMCLhIsL3YxL3tuYW1lPXRhc2tzLyovcHVzaE5vdGlmaWNhdGlvbkNvbmZpZ3MvKn0SvgEKHkxpc3RUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZxItLmEyYS52MS5MaXN0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWdSZXF1ZXN0Gi4uYTJhLnYxLkxpc3RUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1Jlc3BvbnNlIj3aQQZwYXJlbnSC0+STAi4SLC92MS97cGFyZW50PXRhc2tzLyp9L3B1c2hOb3RpZmljYXRpb25Db25maWdzElAKDEdldEFnZW50Q2FyZBIbLmEyYS52MS5HZXRBZ2VudENhcmRSZXF1ZXN0GhEuYTJhLnYxLkFnZW50Q2FyZCIQgtPkkwIKEggvdjEvY2FyZBKoAQogRGVsZXRlVGFza1B1c2hOb3RpZmljYXRpb25Db25maWcSLy5hMmEudjEuRGVsZXRlVGFza1B1c2hOb3RpZmljYXRpb25Db25maWdSZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IjvaQQRuYW1lgtPkkwIuKiwvdjEve25hbWU9dGFza3MvKi9wdXNoTm90aWZpY2F0aW9uQ29uZmlncy8qfUJzCgpjb20uYTJhLnYxQghBMmFQcm90b1ABWiJnaXRodWIuY29tL2EyYXByb2plY3QvYTJhLWdvL2EyYXBiogIDQVhYqgIGQTJhLlYxygIGQTJhXFYx4gISQTJhXFYxXEdQQk1ldGFkYXRh6gIHQTJhOjpWMWIGcHJvdG8z", [file_google_api_annotations, file_google_api_client, file_google_api_field_behavior, file_google_protobuf_empty, file_google_protobuf_struct, file_google_protobuf_timestamp]);

/**
 * --8<-- [start:MessageSendConfiguration]
 * Configuration of a send message request.
 *
 * @generated from message a2a.v1.SendMessageConfiguration
 */
export type SendMessageConfiguration = Message$1<"a2a.v1.SendMessageConfiguration"> & {
  /**
   * The output modes that the agent is expected to respond with.
   *
   * @generated from field: repeated string accepted_output_modes = 1;
   */
  acceptedOutputModes: string[];

  /**
   * A configuration of a webhook that can be used to receive updates
   *
   * @generated from field: a2a.v1.PushNotificationConfig push_notification = 2;
   */
  pushNotification?: PushNotificationConfig;

  /**
   * The maximum number of messages to include in the history. if 0, the
   * history will be unlimited.
   *
   * @generated from field: int32 history_length = 3;
   */
  historyLength: number;

  /**
   * If true, the message will be blocking until the task is completed. If
   * false, the message will be non-blocking and the task will be returned
   * immediately. It is the caller's responsibility to check for any task
   * updates.
   *
   * @generated from field: bool blocking = 4;
   */
  blocking: boolean;
};

/**
 * Describes the message a2a.v1.SendMessageConfiguration.
 * Use `create(SendMessageConfigurationSchema)` to create a new message.
 */
export const SendMessageConfigurationSchema: GenMessage<SendMessageConfiguration> = /*@__PURE__*/
  messageDesc(file_a2a, 0);

/**
 * --8<-- [start:Task]
 * Task is the core unit of action for A2A. It has a current status
 * and when results are created for the task they are stored in the
 * artifact. If there are multiple turns for a task, these are stored in
 * history.
 *
 * @generated from message a2a.v1.Task
 */
export type Task = Message$1<"a2a.v1.Task"> & {
  /**
   * Unique identifier (e.g. UUID) for the task, generated by the server for a
   * new task.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Unique identifier (e.g. UUID) for the contextual collection of interactions
   * (tasks and messages). Created by the A2A server.
   *
   * @generated from field: string context_id = 2;
   */
  contextId: string;

  /**
   * The current status of a Task, including state and a message.
   *
   * @generated from field: a2a.v1.TaskStatus status = 3;
   */
  status?: TaskStatus;

  /**
   * A set of output artifacts for a Task.
   *
   * @generated from field: repeated a2a.v1.Artifact artifacts = 4;
   */
  artifacts: Artifact[];

  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * The history of interactions from a task.
   *
   * @generated from field: repeated a2a.v1.Message history = 5;
   */
  history: Message[];

  /**
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   * A key/value object to store custom metadata about a task.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message a2a.v1.Task.
 * Use `create(TaskSchema)` to create a new message.
 */
export const TaskSchema: GenMessage<Task> = /*@__PURE__*/
  messageDesc(file_a2a, 1);

/**
 * --8<-- [start:TaskStatus]
 * A container for the status of a task
 *
 * @generated from message a2a.v1.TaskStatus
 */
export type TaskStatus = Message$1<"a2a.v1.TaskStatus"> & {
  /**
   * The current state of this task
   *
   * @generated from field: a2a.v1.TaskState state = 1;
   */
  state: TaskState;

  /**
   * A message associated with the status.
   *
   * @generated from field: a2a.v1.Message update = 2 [json_name = "message"];
   */
  update?: Message;

  /**
   * Timestamp when the status was recorded.
   * Example: "2023-10-27T10:00:00Z"
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;
};

/**
 * Describes the message a2a.v1.TaskStatus.
 * Use `create(TaskStatusSchema)` to create a new message.
 */
export const TaskStatusSchema: GenMessage<TaskStatus> = /*@__PURE__*/
  messageDesc(file_a2a, 2);

/**
 * --8<-- [start:Part]
 * Part represents a container for a section of communication content.
 * Parts can be purely textual, some sort of file (image, video, etc) or
 * a structured data blob (i.e. JSON).
 *
 * @generated from message a2a.v1.Part
 */
export type Part = Message$1<"a2a.v1.Part"> & {
  /**
   * @generated from oneof a2a.v1.Part.part
   */
  part: {
    /**
     * @generated from field: string text = 1;
     */
    value: string;
    case: "text";
  } | {
    /**
     * @generated from field: a2a.v1.FilePart file = 2;
     */
    value: FilePart;
    case: "file";
  } | {
    /**
     * @generated from field: a2a.v1.DataPart data = 3;
     */
    value: DataPart;
    case: "data";
  } | { case: undefined; value?: undefined };

  /**
   * Optional metadata associated with this part.
   *
   * @generated from field: google.protobuf.Struct metadata = 4;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message a2a.v1.Part.
 * Use `create(PartSchema)` to create a new message.
 */
export const PartSchema: GenMessage<Part> = /*@__PURE__*/
  messageDesc(file_a2a, 3);

/**
 * --8<-- [start:FilePart]
 * FilePart represents the different ways files can be provided. If files are
 * small, directly feeding the bytes is supported via file_with_bytes. If the
 * file is large, the agent should read the content as appropriate directly
 * from the file_with_uri source.
 *
 * @generated from message a2a.v1.FilePart
 */
export type FilePart = Message$1<"a2a.v1.FilePart"> & {
  /**
   * @generated from oneof a2a.v1.FilePart.file
   */
  file: {
    /**
     * @generated from field: string file_with_uri = 1;
     */
    value: string;
    case: "fileWithUri";
  } | {
    /**
     * @generated from field: bytes file_with_bytes = 2;
     */
    value: Uint8Array;
    case: "fileWithBytes";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: string mime_type = 3;
   */
  mimeType: string;

  /**
   * @generated from field: string name = 4;
   */
  name: string;
};

/**
 * Describes the message a2a.v1.FilePart.
 * Use `create(FilePartSchema)` to create a new message.
 */
export const FilePartSchema: GenMessage<FilePart> = /*@__PURE__*/
  messageDesc(file_a2a, 4);

/**
 * --8<-- [start:DataPart]
 * DataPart represents a structured blob. This is most commonly a JSON payload.
 *
 * @generated from message a2a.v1.DataPart
 */
export type DataPart = Message$1<"a2a.v1.DataPart"> & {
  /**
   * @generated from field: google.protobuf.Struct data = 1;
   */
  data?: JsonObject;
};

/**
 * Describes the message a2a.v1.DataPart.
 * Use `create(DataPartSchema)` to create a new message.
 */
export const DataPartSchema: GenMessage<DataPart> = /*@__PURE__*/
  messageDesc(file_a2a, 5);

/**
 * --8<-- [start:Message]
 * Message is one unit of communication between client and server. It is
 * associated with a context and optionally a task. Since the server is
 * responsible for the context definition, it must always provide a context_id
 * in its messages. The client can optionally provide the context_id if it
 * knows the context to associate the message to. Similarly for task_id,
 * except the server decides if a task is created and whether to include the
 * task_id.
 *
 * @generated from message a2a.v1.Message
 */
export type Message = Message$1<"a2a.v1.Message"> & {
  /**
   * The unique identifier (e.g. UUID)of the message. This is required and
   * created by the message creator.
   *
   * @generated from field: string message_id = 1;
   */
  messageId: string;

  /**
   * The context id of the message. This is optional and if set, the message
   * will be associated with the given context.
   *
   * @generated from field: string context_id = 2;
   */
  contextId: string;

  /**
   * The task id of the message. This is optional and if set, the message
   * will be associated with the given task.
   *
   * @generated from field: string task_id = 3;
   */
  taskId: string;

  /**
   * A role for the message.
   *
   * @generated from field: a2a.v1.Role role = 4;
   */
  role: Role;

  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * Parts is the container of the message content.
   *
   * @generated from field: repeated a2a.v1.Part parts = 5;
   */
  parts: Part[];

  /**
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   * Any optional metadata to provide along with the message.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;

  /**
   * The URIs of extensions that are present or contributed to this Message.
   *
   * @generated from field: repeated string extensions = 7;
   */
  extensions: string[];

  /**
   * A list of task IDs that this message references for additional context.
   *
   * @generated from field: repeated string reference_task_ids = 8;
   */
  referenceTaskIds: string[];
};

/**
 * Describes the message a2a.v1.Message.
 * Use `create(MessageSchema)` to create a new message.
 */
export const MessageSchema: GenMessage<Message> = /*@__PURE__*/
  messageDesc(file_a2a, 6);

/**
 * --8<-- [start:Artifact]
 * Artifacts are the container for task completed results. These are similar
 * to Messages but are intended to be the product of a task, as opposed to
 * point-to-point communication.
 *
 * @generated from message a2a.v1.Artifact
 */
export type Artifact = Message$1<"a2a.v1.Artifact"> & {
  /**
   * Unique identifier (e.g. UUID) for the artifact. It must be at least unique
   * within a task.
   *
   * @generated from field: string artifact_id = 1;
   */
  artifactId: string;

  /**
   * A human readable name for the artifact.
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * A human readable description of the artifact, optional.
   *
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * The content of the artifact.
   *
   * @generated from field: repeated a2a.v1.Part parts = 5;
   */
  parts: Part[];

  /**
   * Optional metadata included with the artifact.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;

  /**
   * The URIs of extensions that are present or contributed to this Artifact.
   *
   * @generated from field: repeated string extensions = 7;
   */
  extensions: string[];
};

/**
 * Describes the message a2a.v1.Artifact.
 * Use `create(ArtifactSchema)` to create a new message.
 */
export const ArtifactSchema: GenMessage<Artifact> = /*@__PURE__*/
  messageDesc(file_a2a, 7);

/**
 * --8<-- [start:TaskStatusUpdateEvent]
 * TaskStatusUpdateEvent is a delta even on a task indicating that a task
 * has changed.
 *
 * @generated from message a2a.v1.TaskStatusUpdateEvent
 */
export type TaskStatusUpdateEvent = Message$1<"a2a.v1.TaskStatusUpdateEvent"> & {
  /**
   * The id of the task that is changed
   *
   * @generated from field: string task_id = 1;
   */
  taskId: string;

  /**
   * The id of the context that the task belongs to
   *
   * @generated from field: string context_id = 2;
   */
  contextId: string;

  /**
   * The new status of the task.
   *
   * @generated from field: a2a.v1.TaskStatus status = 3;
   */
  status?: TaskStatus;

  /**
   * Whether this is the last status update expected for this task.
   *
   * @generated from field: bool final = 4;
   */
  final: boolean;

  /**
   * Optional metadata to associate with the task update.
   *
   * @generated from field: google.protobuf.Struct metadata = 5;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message a2a.v1.TaskStatusUpdateEvent.
 * Use `create(TaskStatusUpdateEventSchema)` to create a new message.
 */
export const TaskStatusUpdateEventSchema: GenMessage<TaskStatusUpdateEvent> = /*@__PURE__*/
  messageDesc(file_a2a, 8);

/**
 * --8<-- [start:TaskArtifactUpdateEvent]
 * TaskArtifactUpdateEvent represents a task delta where an artifact has
 * been generated.
 *
 * @generated from message a2a.v1.TaskArtifactUpdateEvent
 */
export type TaskArtifactUpdateEvent = Message$1<"a2a.v1.TaskArtifactUpdateEvent"> & {
  /**
   * The id of the task for this artifact
   *
   * @generated from field: string task_id = 1;
   */
  taskId: string;

  /**
   * The id of the context that this task belongs too
   *
   * @generated from field: string context_id = 2;
   */
  contextId: string;

  /**
   * The artifact itself
   *
   * @generated from field: a2a.v1.Artifact artifact = 3;
   */
  artifact?: Artifact;

  /**
   *  Whether this should be appended to a prior one produced
   *
   * @generated from field: bool append = 4;
   */
  append: boolean;

  /**
   * Whether this represents the last part of an artifact
   *
   * @generated from field: bool last_chunk = 5;
   */
  lastChunk: boolean;

  /**
   * Optional metadata associated with the artifact update.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message a2a.v1.TaskArtifactUpdateEvent.
 * Use `create(TaskArtifactUpdateEventSchema)` to create a new message.
 */
export const TaskArtifactUpdateEventSchema: GenMessage<TaskArtifactUpdateEvent> = /*@__PURE__*/
  messageDesc(file_a2a, 9);

/**
 * --8<-- [start:PushNotificationConfig]
 * Configuration for setting up push notifications for task updates.
 *
 * @generated from message a2a.v1.PushNotificationConfig
 */
export type PushNotificationConfig = Message$1<"a2a.v1.PushNotificationConfig"> & {
  /**
   * A unique identifier (e.g. UUID) for this push notification.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Url to send the notification too
   *
   * @generated from field: string url = 2;
   */
  url: string;

  /**
   * Token unique for this task/session
   *
   * @generated from field: string token = 3;
   */
  token: string;

  /**
   * Information about the authentication to sent with the notification
   *
   * @generated from field: a2a.v1.AuthenticationInfo authentication = 4;
   */
  authentication?: AuthenticationInfo;
};

/**
 * Describes the message a2a.v1.PushNotificationConfig.
 * Use `create(PushNotificationConfigSchema)` to create a new message.
 */
export const PushNotificationConfigSchema: GenMessage<PushNotificationConfig> = /*@__PURE__*/
  messageDesc(file_a2a, 10);

/**
 * --8<-- [start:PushNotificationAuthenticationInfo]
 * Defines authentication details, used for push notifications.
 *
 * @generated from message a2a.v1.AuthenticationInfo
 */
export type AuthenticationInfo = Message$1<"a2a.v1.AuthenticationInfo"> & {
  /**
   * Supported authentication schemes - e.g. Basic, Bearer, etc
   *
   * @generated from field: repeated string schemes = 1;
   */
  schemes: string[];

  /**
   * Optional credentials
   *
   * @generated from field: string credentials = 2;
   */
  credentials: string;
};

/**
 * Describes the message a2a.v1.AuthenticationInfo.
 * Use `create(AuthenticationInfoSchema)` to create a new message.
 */
export const AuthenticationInfoSchema: GenMessage<AuthenticationInfo> = /*@__PURE__*/
  messageDesc(file_a2a, 11);

/**
 * --8<-- [start:AgentInterface]
 * Defines additional transport information for the agent.
 *
 * @generated from message a2a.v1.AgentInterface
 */
export type AgentInterface = Message$1<"a2a.v1.AgentInterface"> & {
  /**
   * The url this interface is found at.
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * The transport supported this url. This is an open form string, to be
   * easily extended for many transport protocols. The core ones officially
   * supported are JSONRPC, GRPC and HTTP+JSON.
   *
   * @generated from field: string transport = 2;
   */
  transport: string;
};

/**
 * Describes the message a2a.v1.AgentInterface.
 * Use `create(AgentInterfaceSchema)` to create a new message.
 */
export const AgentInterfaceSchema: GenMessage<AgentInterface> = /*@__PURE__*/
  messageDesc(file_a2a, 12);

/**
 * --8<-- [start:AgentCard]
 * AgentCard conveys key information:
 * - Overall details (version, name, description, uses)
 * - Skills; a set of actions/solutions the agent can perform
 * - Default modalities/content types supported by the agent.
 * - Authentication requirements
 * Next ID: 19
 *
 * @generated from message a2a.v1.AgentCard
 */
export type AgentCard = Message$1<"a2a.v1.AgentCard"> & {
  /**
   * The version of the A2A protocol this agent supports.
   *
   * @generated from field: string protocol_version = 16;
   */
  protocolVersion: string;

  /**
   * A human readable name for the agent.
   * Example: "Recipe Agent"
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A description of the agent's domain of action/solution space.
   * Example: "Agent that helps users with recipes and cooking."
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * A URL to the address the agent is hosted at. This represents the
   * preferred endpoint as declared by the agent.
   *
   * @generated from field: string url = 3;
   */
  url: string;

  /**
   * The transport of the preferred endpoint. If empty, defaults to JSONRPC.
   *
   * @generated from field: string preferred_transport = 14;
   */
  preferredTransport: string;

  /**
   * Announcement of additional supported transports. Client can use any of
   * the supported transports.
   *
   * @generated from field: repeated a2a.v1.AgentInterface additional_interfaces = 15;
   */
  additionalInterfaces: AgentInterface[];

  /**
   * The service provider of the agent.
   *
   * @generated from field: a2a.v1.AgentProvider provider = 4;
   */
  provider?: AgentProvider;

  /**
   * The version of the agent.
   * Example: "1.0.0"
   *
   * @generated from field: string version = 5;
   */
  version: string;

  /**
   * A url to provide additional documentation about the agent.
   *
   * @generated from field: string documentation_url = 6;
   */
  documentationUrl: string;

  /**
   * A2A Capability set supported by the agent.
   *
   * @generated from field: a2a.v1.AgentCapabilities capabilities = 7;
   */
  capabilities?: AgentCapabilities;

  /**
   * The security scheme details used for authenticating with this agent.
   *
   * @generated from field: map<string, a2a.v1.SecurityScheme> security_schemes = 8;
   */
  securitySchemes: { [key: string]: SecurityScheme };

  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * Security requirements for contacting the agent.
   * This list can be seen as an OR of ANDs. Each object in the list describes
   * one possible set of security requirements that must be present on a
   * request. This allows specifying, for example, "callers must either use
   * OAuth OR an API Key AND mTLS."
   * Example:
   * security {
   *   schemes { key: "oauth" value { list: ["read"] } }
   * }
   * security {
   *   schemes { key: "api-key" }
   *   schemes { key: "mtls" }
   * }
   *
   * @generated from field: repeated a2a.v1.Security security = 9;
   */
  security: Security[];

  /**
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   * The set of interaction modes that the agent supports across all skills.
   * This can be overridden per skill. Defined as mime types.
   *
   * @generated from field: repeated string default_input_modes = 10;
   */
  defaultInputModes: string[];

  /**
   * The mime types supported as outputs from this agent.
   *
   * @generated from field: repeated string default_output_modes = 11;
   */
  defaultOutputModes: string[];

  /**
   * Skills represent a unit of ability an agent can perform. This may
   * somewhat abstract but represents a more focused set of actions that the
   * agent is highly likely to succeed at.
   *
   * @generated from field: repeated a2a.v1.AgentSkill skills = 12;
   */
  skills: AgentSkill[];

  /**
   * Whether the agent supports providing an extended agent card when
   * the user is authenticated, i.e. is the card from .well-known
   * different than the card from GetAgentCard.
   *
   * @generated from field: bool supports_authenticated_extended_card = 13;
   */
  supportsAuthenticatedExtendedCard: boolean;

  /**
   * JSON Web Signatures computed for this AgentCard.
   *
   * @generated from field: repeated a2a.v1.AgentCardSignature signatures = 17;
   */
  signatures: AgentCardSignature[];

  /**
   * An optional URL to an icon for the agent.
   *
   * @generated from field: string icon_url = 18;
   */
  iconUrl: string;
};

/**
 * Describes the message a2a.v1.AgentCard.
 * Use `create(AgentCardSchema)` to create a new message.
 */
export const AgentCardSchema: GenMessage<AgentCard> = /*@__PURE__*/
  messageDesc(file_a2a, 13);

/**
 * --8<-- [start:AgentProvider]
 * Represents information about the service provider of an agent.
 *
 * @generated from message a2a.v1.AgentProvider
 */
export type AgentProvider = Message$1<"a2a.v1.AgentProvider"> & {
  /**
   * The providers reference url
   * Example: "https://ai.google.dev"
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * The providers organization name
   * Example: "Google"
   *
   * @generated from field: string organization = 2;
   */
  organization: string;
};

/**
 * Describes the message a2a.v1.AgentProvider.
 * Use `create(AgentProviderSchema)` to create a new message.
 */
export const AgentProviderSchema: GenMessage<AgentProvider> = /*@__PURE__*/
  messageDesc(file_a2a, 14);

/**
 * --8<-- [start:AgentCapabilities]
 * Defines the A2A feature set supported by the agent
 *
 * @generated from message a2a.v1.AgentCapabilities
 */
export type AgentCapabilities = Message$1<"a2a.v1.AgentCapabilities"> & {
  /**
   * If the agent will support streaming responses
   *
   * @generated from field: bool streaming = 1;
   */
  streaming: boolean;

  /**
   * If the agent can send push notifications to the clients webhook
   *
   * @generated from field: bool push_notifications = 2;
   */
  pushNotifications: boolean;

  /**
   * Extensions supported by this agent.
   *
   * @generated from field: repeated a2a.v1.AgentExtension extensions = 3;
   */
  extensions: AgentExtension[];

  /**
   * If the agent provides a history of state transitions for a task.
   *
   * @generated from field: bool state_transition_history = 4;
   */
  stateTransitionHistory: boolean;
};

/**
 * Describes the message a2a.v1.AgentCapabilities.
 * Use `create(AgentCapabilitiesSchema)` to create a new message.
 */
export const AgentCapabilitiesSchema: GenMessage<AgentCapabilities> = /*@__PURE__*/
  messageDesc(file_a2a, 15);

/**
 * --8<-- [start:AgentExtension]
 * A declaration of an extension supported by an Agent.
 *
 * @generated from message a2a.v1.AgentExtension
 */
export type AgentExtension = Message$1<"a2a.v1.AgentExtension"> & {
  /**
   * The URI of the extension.
   * Example: "https://developers.google.com/identity/protocols/oauth2"
   *
   * @generated from field: string uri = 1;
   */
  uri: string;

  /**
   * A description of how this agent uses this extension.
   * Example: "Google OAuth 2.0 authentication"
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * Whether the client must follow specific requirements of the extension.
   * Example: false
   *
   * @generated from field: bool required = 3;
   */
  required: boolean;

  /**
   * Optional configuration for the extension.
   *
   * @generated from field: google.protobuf.Struct params = 4;
   */
  params?: JsonObject;
};

/**
 * Describes the message a2a.v1.AgentExtension.
 * Use `create(AgentExtensionSchema)` to create a new message.
 */
export const AgentExtensionSchema: GenMessage<AgentExtension> = /*@__PURE__*/
  messageDesc(file_a2a, 16);

/**
 * --8<-- [start:AgentSkill]
 * AgentSkill represents a unit of action/solution that the agent can perform.
 * One can think of this as a type of highly reliable solution that an agent
 * can be tasked to provide. Agents have the autonomy to choose how and when
 * to use specific skills, but clients should have confidence that if the
 * skill is defined that unit of action can be reliably performed.
 *
 * @generated from message a2a.v1.AgentSkill
 */
export type AgentSkill = Message$1<"a2a.v1.AgentSkill"> & {
  /**
   * Unique identifier of the skill within this agent.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * A human readable name for the skill.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * A human (or llm) readable description of the skill
   * details and behaviors.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * A set of tags for the skill to enhance categorization/utilization.
   * Example: ["cooking", "customer support", "billing"]
   *
   * @generated from field: repeated string tags = 4;
   */
  tags: string[];

  /**
   * A set of example queries that this skill is designed to address.
   * These examples should help the caller to understand how to craft requests
   * to the agent to achieve specific goals.
   * Example: ["I need a recipe for bread"]
   *
   * @generated from field: repeated string examples = 5;
   */
  examples: string[];

  /**
   * Possible input modalities supported.
   *
   * @generated from field: repeated string input_modes = 6;
   */
  inputModes: string[];

  /**
   * Possible output modalities produced
   *
   * @generated from field: repeated string output_modes = 7;
   */
  outputModes: string[];

  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * Security schemes necessary for the agent to leverage this skill.
   * As in the overall AgentCard.security, this list represents a logical OR of
   * security requirement objects. Each object is a set of security schemes
   * that must be used together (a logical AND).
   *
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   *
   * @generated from field: repeated a2a.v1.Security security = 8;
   */
  security: Security[];
};

/**
 * Describes the message a2a.v1.AgentSkill.
 * Use `create(AgentSkillSchema)` to create a new message.
 */
export const AgentSkillSchema: GenMessage<AgentSkill> = /*@__PURE__*/
  messageDesc(file_a2a, 17);

/**
 * --8<-- [start:AgentCardSignature]
 * AgentCardSignature represents a JWS signature of an AgentCard.
 * This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
 *
 * @generated from message a2a.v1.AgentCardSignature
 */
export type AgentCardSignature = Message$1<"a2a.v1.AgentCardSignature"> & {
  /**
   * The protected JWS header for the signature. This is always a
   * base64url-encoded JSON object. Required.
   *
   * @generated from field: string protected = 1;
   */
  protected: string;

  /**
   * The computed signature, base64url-encoded. Required.
   *
   * @generated from field: string signature = 2;
   */
  signature: string;

  /**
   * The unprotected JWS header values.
   *
   * @generated from field: google.protobuf.Struct header = 3;
   */
  header?: JsonObject;
};

/**
 * Describes the message a2a.v1.AgentCardSignature.
 * Use `create(AgentCardSignatureSchema)` to create a new message.
 */
export const AgentCardSignatureSchema: GenMessage<AgentCardSignature> = /*@__PURE__*/
  messageDesc(file_a2a, 18);

/**
 * --8<-- [start:TaskPushNotificationConfig]
 *
 * @generated from message a2a.v1.TaskPushNotificationConfig
 */
export type TaskPushNotificationConfig = Message$1<"a2a.v1.TaskPushNotificationConfig"> & {
  /**
   * The resource name of the config.
   * Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The push notification configuration details.
   *
   * @generated from field: a2a.v1.PushNotificationConfig push_notification_config = 2;
   */
  pushNotificationConfig?: PushNotificationConfig;
};

/**
 * Describes the message a2a.v1.TaskPushNotificationConfig.
 * Use `create(TaskPushNotificationConfigSchema)` to create a new message.
 */
export const TaskPushNotificationConfigSchema: GenMessage<TaskPushNotificationConfig> = /*@__PURE__*/
  messageDesc(file_a2a, 19);

/**
 * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
 *
 * @generated from message a2a.v1.StringList
 */
export type StringList = Message$1<"a2a.v1.StringList"> & {
  /**
   * @generated from field: repeated string list = 1;
   */
  list: string[];
};

/**
 * Describes the message a2a.v1.StringList.
 * Use `create(StringListSchema)` to create a new message.
 */
export const StringListSchema: GenMessage<StringList> = /*@__PURE__*/
  messageDesc(file_a2a, 20);

/**
 * @generated from message a2a.v1.Security
 */
export type Security = Message$1<"a2a.v1.Security"> & {
  /**
   * @generated from field: map<string, a2a.v1.StringList> schemes = 1;
   */
  schemes: { [key: string]: StringList };
};

/**
 * Describes the message a2a.v1.Security.
 * Use `create(SecuritySchema)` to create a new message.
 */
export const SecuritySchema: GenMessage<Security> = /*@__PURE__*/
  messageDesc(file_a2a, 21);

/**
 * --8<-- [start:SecurityScheme]
 *
 * @generated from message a2a.v1.SecurityScheme
 */
export type SecurityScheme = Message$1<"a2a.v1.SecurityScheme"> & {
  /**
   * @generated from oneof a2a.v1.SecurityScheme.scheme
   */
  scheme: {
    /**
     * @generated from field: a2a.v1.APIKeySecurityScheme api_key_security_scheme = 1;
     */
    value: APIKeySecurityScheme;
    case: "apiKeySecurityScheme";
  } | {
    /**
     * @generated from field: a2a.v1.HTTPAuthSecurityScheme http_auth_security_scheme = 2;
     */
    value: HTTPAuthSecurityScheme;
    case: "httpAuthSecurityScheme";
  } | {
    /**
     * @generated from field: a2a.v1.OAuth2SecurityScheme oauth2_security_scheme = 3;
     */
    value: OAuth2SecurityScheme;
    case: "oauth2SecurityScheme";
  } | {
    /**
     * @generated from field: a2a.v1.OpenIdConnectSecurityScheme open_id_connect_security_scheme = 4;
     */
    value: OpenIdConnectSecurityScheme;
    case: "openIdConnectSecurityScheme";
  } | {
    /**
     * @generated from field: a2a.v1.MutualTlsSecurityScheme mtls_security_scheme = 5;
     */
    value: MutualTlsSecurityScheme;
    case: "mtlsSecurityScheme";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message a2a.v1.SecurityScheme.
 * Use `create(SecuritySchemeSchema)` to create a new message.
 */
export const SecuritySchemeSchema: GenMessage<SecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 22);

/**
 * --8<-- [start:APIKeySecurityScheme]
 *
 * @generated from message a2a.v1.APIKeySecurityScheme
 */
export type APIKeySecurityScheme = Message$1<"a2a.v1.APIKeySecurityScheme"> & {
  /**
   * Description of this security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * Location of the API key, valid values are "query", "header", or "cookie"
   *
   * @generated from field: string location = 2;
   */
  location: string;

  /**
   * Name of the header, query or cookie parameter to be used.
   *
   * @generated from field: string name = 3;
   */
  name: string;
};

/**
 * Describes the message a2a.v1.APIKeySecurityScheme.
 * Use `create(APIKeySecuritySchemeSchema)` to create a new message.
 */
export const APIKeySecuritySchemeSchema: GenMessage<APIKeySecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 23);

/**
 * --8<-- [start:HTTPAuthSecurityScheme]
 *
 * @generated from message a2a.v1.HTTPAuthSecurityScheme
 */
export type HTTPAuthSecurityScheme = Message$1<"a2a.v1.HTTPAuthSecurityScheme"> & {
  /**
   * Description of this security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * The name of the HTTP Authentication scheme to be used in the
   * Authorization header as defined in RFC7235. The values used SHOULD be
   * registered in the IANA Authentication Scheme registry.
   * The value is case-insensitive, as defined in RFC7235.
   *
   * @generated from field: string scheme = 2;
   */
  scheme: string;

  /**
   * A hint to the client to identify how the bearer token is formatted.
   * Bearer tokens are usually generated by an authorization server, so
   * this information is primarily for documentation purposes.
   *
   * @generated from field: string bearer_format = 3;
   */
  bearerFormat: string;
};

/**
 * Describes the message a2a.v1.HTTPAuthSecurityScheme.
 * Use `create(HTTPAuthSecuritySchemeSchema)` to create a new message.
 */
export const HTTPAuthSecuritySchemeSchema: GenMessage<HTTPAuthSecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 24);

/**
 * --8<-- [start:OAuth2SecurityScheme]
 *
 * @generated from message a2a.v1.OAuth2SecurityScheme
 */
export type OAuth2SecurityScheme = Message$1<"a2a.v1.OAuth2SecurityScheme"> & {
  /**
   * Description of this security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * An object containing configuration information for the flow types supported
   *
   * @generated from field: a2a.v1.OAuthFlows flows = 2;
   */
  flows?: OAuthFlows;

  /**
   * URL to the oauth2 authorization server metadata
   * [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
   *
   * @generated from field: string oauth2_metadata_url = 3;
   */
  oauth2MetadataUrl: string;
};

/**
 * Describes the message a2a.v1.OAuth2SecurityScheme.
 * Use `create(OAuth2SecuritySchemeSchema)` to create a new message.
 */
export const OAuth2SecuritySchemeSchema: GenMessage<OAuth2SecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 25);

/**
 * --8<-- [start:OpenIdConnectSecurityScheme]
 *
 * @generated from message a2a.v1.OpenIdConnectSecurityScheme
 */
export type OpenIdConnectSecurityScheme = Message$1<"a2a.v1.OpenIdConnectSecurityScheme"> & {
  /**
   * Description of this security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * Well-known URL to discover the [[OpenID-Connect-Discovery]] provider
   * metadata.
   *
   * @generated from field: string open_id_connect_url = 2;
   */
  openIdConnectUrl: string;
};

/**
 * Describes the message a2a.v1.OpenIdConnectSecurityScheme.
 * Use `create(OpenIdConnectSecuritySchemeSchema)` to create a new message.
 */
export const OpenIdConnectSecuritySchemeSchema: GenMessage<OpenIdConnectSecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 26);

/**
 * --8<-- [start:MutualTLSSecurityScheme]
 *
 * @generated from message a2a.v1.MutualTlsSecurityScheme
 */
export type MutualTlsSecurityScheme = Message$1<"a2a.v1.MutualTlsSecurityScheme"> & {
  /**
   * Description of this security scheme.
   *
   * @generated from field: string description = 1;
   */
  description: string;
};

/**
 * Describes the message a2a.v1.MutualTlsSecurityScheme.
 * Use `create(MutualTlsSecuritySchemeSchema)` to create a new message.
 */
export const MutualTlsSecuritySchemeSchema: GenMessage<MutualTlsSecurityScheme> = /*@__PURE__*/
  messageDesc(file_a2a, 27);

/**
 * --8<-- [start:OAuthFlows]
 *
 * @generated from message a2a.v1.OAuthFlows
 */
export type OAuthFlows = Message$1<"a2a.v1.OAuthFlows"> & {
  /**
   * @generated from oneof a2a.v1.OAuthFlows.flow
   */
  flow: {
    /**
     * @generated from field: a2a.v1.AuthorizationCodeOAuthFlow authorization_code = 1;
     */
    value: AuthorizationCodeOAuthFlow;
    case: "authorizationCode";
  } | {
    /**
     * @generated from field: a2a.v1.ClientCredentialsOAuthFlow client_credentials = 2;
     */
    value: ClientCredentialsOAuthFlow;
    case: "clientCredentials";
  } | {
    /**
     * @generated from field: a2a.v1.ImplicitOAuthFlow implicit = 3;
     */
    value: ImplicitOAuthFlow;
    case: "implicit";
  } | {
    /**
     * @generated from field: a2a.v1.PasswordOAuthFlow password = 4;
     */
    value: PasswordOAuthFlow;
    case: "password";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message a2a.v1.OAuthFlows.
 * Use `create(OAuthFlowsSchema)` to create a new message.
 */
export const OAuthFlowsSchema: GenMessage<OAuthFlows> = /*@__PURE__*/
  messageDesc(file_a2a, 28);

/**
 * --8<-- [start:AuthorizationCodeOAuthFlow]
 *
 * @generated from message a2a.v1.AuthorizationCodeOAuthFlow
 */
export type AuthorizationCodeOAuthFlow = Message$1<"a2a.v1.AuthorizationCodeOAuthFlow"> & {
  /**
   * The authorization URL to be used for this flow. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS
   *
   * @generated from field: string authorization_url = 1;
   */
  authorizationUrl: string;

  /**
   * The token URL to be used for this flow. This MUST be in the form of a URL.
   * The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string token_url = 2;
   */
  tokenUrl: string;

  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string refresh_url = 3;
   */
  refreshUrl: string;

  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   *
   * @generated from field: map<string, string> scopes = 4;
   */
  scopes: { [key: string]: string };
};

/**
 * Describes the message a2a.v1.AuthorizationCodeOAuthFlow.
 * Use `create(AuthorizationCodeOAuthFlowSchema)` to create a new message.
 */
export const AuthorizationCodeOAuthFlowSchema: GenMessage<AuthorizationCodeOAuthFlow> = /*@__PURE__*/
  messageDesc(file_a2a, 29);

/**
 * --8<-- [start:ClientCredentialsOAuthFlow]
 *
 * @generated from message a2a.v1.ClientCredentialsOAuthFlow
 */
export type ClientCredentialsOAuthFlow = Message$1<"a2a.v1.ClientCredentialsOAuthFlow"> & {
  /**
   * The token URL to be used for this flow. This MUST be in the form of a URL.
   * The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string token_url = 1;
   */
  tokenUrl: string;

  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string refresh_url = 2;
   */
  refreshUrl: string;

  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   *
   * @generated from field: map<string, string> scopes = 3;
   */
  scopes: { [key: string]: string };
};

/**
 * Describes the message a2a.v1.ClientCredentialsOAuthFlow.
 * Use `create(ClientCredentialsOAuthFlowSchema)` to create a new message.
 */
export const ClientCredentialsOAuthFlowSchema: GenMessage<ClientCredentialsOAuthFlow> = /*@__PURE__*/
  messageDesc(file_a2a, 30);

/**
 * --8<-- [start:ImplicitOAuthFlow]
 *
 * @generated from message a2a.v1.ImplicitOAuthFlow
 */
export type ImplicitOAuthFlow = Message$1<"a2a.v1.ImplicitOAuthFlow"> & {
  /**
   * The authorization URL to be used for this flow. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS
   *
   * @generated from field: string authorization_url = 1;
   */
  authorizationUrl: string;

  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string refresh_url = 2;
   */
  refreshUrl: string;

  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   *
   * @generated from field: map<string, string> scopes = 3;
   */
  scopes: { [key: string]: string };
};

/**
 * Describes the message a2a.v1.ImplicitOAuthFlow.
 * Use `create(ImplicitOAuthFlowSchema)` to create a new message.
 */
export const ImplicitOAuthFlowSchema: GenMessage<ImplicitOAuthFlow> = /*@__PURE__*/
  messageDesc(file_a2a, 31);

/**
 * --8<-- [start:PasswordOAuthFlow]
 *
 * @generated from message a2a.v1.PasswordOAuthFlow
 */
export type PasswordOAuthFlow = Message$1<"a2a.v1.PasswordOAuthFlow"> & {
  /**
   * The token URL to be used for this flow. This MUST be in the form of a URL.
   * The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string token_url = 1;
   */
  tokenUrl: string;

  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   *
   * @generated from field: string refresh_url = 2;
   */
  refreshUrl: string;

  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   *
   * @generated from field: map<string, string> scopes = 3;
   */
  scopes: { [key: string]: string };
};

/**
 * Describes the message a2a.v1.PasswordOAuthFlow.
 * Use `create(PasswordOAuthFlowSchema)` to create a new message.
 */
export const PasswordOAuthFlowSchema: GenMessage<PasswordOAuthFlow> = /*@__PURE__*/
  messageDesc(file_a2a, 32);

/**
 * /////////// Request Messages ///////////
 * --8<-- [start:MessageSendParams]
 *
 * @generated from message a2a.v1.SendMessageRequest
 */
export type SendMessageRequest = Message$1<"a2a.v1.SendMessageRequest"> & {
  /**
   * The message to send to the agent.
   *
   * @generated from field: a2a.v1.Message request = 1 [json_name = "message"];
   */
  request?: Message;

  /**
   * Configuration for the send request.
   *
   * @generated from field: a2a.v1.SendMessageConfiguration configuration = 2;
   */
  configuration?: SendMessageConfiguration;

  /**
   * Optional metadata for the request.
   *
   * @generated from field: google.protobuf.Struct metadata = 3;
   */
  metadata?: JsonObject;
};

/**
 * Describes the message a2a.v1.SendMessageRequest.
 * Use `create(SendMessageRequestSchema)` to create a new message.
 */
export const SendMessageRequestSchema: GenMessage<SendMessageRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 33);

/**
 * --8<-- [start:GetTaskRequest]
 *
 * @generated from message a2a.v1.GetTaskRequest
 */
export type GetTaskRequest = Message$1<"a2a.v1.GetTaskRequest"> & {
  /**
   * The resource name of the task.
   * Format: tasks/{task_id}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The number of most recent messages from the task's history to retrieve.
   *
   * @generated from field: int32 history_length = 2;
   */
  historyLength: number;
};

/**
 * Describes the message a2a.v1.GetTaskRequest.
 * Use `create(GetTaskRequestSchema)` to create a new message.
 */
export const GetTaskRequestSchema: GenMessage<GetTaskRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 34);

/**
 * --8<-- [start:ListTasksRequest]
 *
 * @generated from message a2a.v1.ListTasksRequest
 */
export type ListTasksRequest = Message$1<"a2a.v1.ListTasksRequest"> & {
  /**
   * Filter tasks by context ID to get tasks from a specific conversation
   * or session.
   *
   * @generated from field: string context_id = 1;
   */
  contextId: string;

  /**
   * Filter tasks by their current status state.
   *
   * @generated from field: a2a.v1.TaskState status = 2;
   */
  status: TaskState;

  /**
   * Maximum number of tasks to return. Must be between 1 and 100.
   * Defaults to 50 if not specified.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Token for pagination. Use the next_page_token from a previous
   * ListTasksResponse.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;

  /**
   * Number of recent messages to include in each task's history.
   * Must be non-negative. Defaults to 0 if not specified.
   *
   * @generated from field: int32 history_length = 5;
   */
  historyLength: number;

  /**
   * Filter tasks updated after this timestamp. Only tasks with a last
   * updated time greater than or equal to this value will be returned.
   *
   * @generated from field: google.protobuf.Timestamp last_updated_time = 6;
   */
  lastUpdatedTime?: Timestamp;

  /**
   * Whether to include artifacts in the returned tasks.
   * Defaults to false to reduce payload size.
   *
   * @generated from field: bool include_artifacts = 7;
   */
  includeArtifacts: boolean;
};

/**
 * Describes the message a2a.v1.ListTasksRequest.
 * Use `create(ListTasksRequestSchema)` to create a new message.
 */
export const ListTasksRequestSchema: GenMessage<ListTasksRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 35);

/**
 * --8<-- [start:ListTasksResponse]
 *
 * @generated from message a2a.v1.ListTasksResponse
 */
export type ListTasksResponse = Message$1<"a2a.v1.ListTasksResponse"> & {
  /**
   * Array of tasks matching the specified criteria.
   *
   * @generated from field: repeated a2a.v1.Task tasks = 1;
   */
  tasks: Task[];

  /**
   * Token for retrieving the next page of results.
   * Empty string if no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * Total number of tasks available (before pagination).
   *
   * @generated from field: int32 total_size = 3;
   */
  totalSize: number;
};

/**
 * Describes the message a2a.v1.ListTasksResponse.
 * Use `create(ListTasksResponseSchema)` to create a new message.
 */
export const ListTasksResponseSchema: GenMessage<ListTasksResponse> = /*@__PURE__*/
  messageDesc(file_a2a, 36);

/**
 * --8<-- [start:CancelTaskRequest]
 *
 * @generated from message a2a.v1.CancelTaskRequest
 */
export type CancelTaskRequest = Message$1<"a2a.v1.CancelTaskRequest"> & {
  /**
   * The resource name of the task to cancel.
   * Format: tasks/{task_id}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message a2a.v1.CancelTaskRequest.
 * Use `create(CancelTaskRequestSchema)` to create a new message.
 */
export const CancelTaskRequestSchema: GenMessage<CancelTaskRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 37);

/**
 * --8<-- [start:GetTaskPushNotificationConfigRequest]
 *
 * @generated from message a2a.v1.GetTaskPushNotificationConfigRequest
 */
export type GetTaskPushNotificationConfigRequest = Message$1<"a2a.v1.GetTaskPushNotificationConfigRequest"> & {
  /**
   * The resource name of the config to retrieve.
   * Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message a2a.v1.GetTaskPushNotificationConfigRequest.
 * Use `create(GetTaskPushNotificationConfigRequestSchema)` to create a new message.
 */
export const GetTaskPushNotificationConfigRequestSchema: GenMessage<GetTaskPushNotificationConfigRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 38);

/**
 * --8<-- [start:DeleteTaskPushNotificationConfigRequest]
 *
 * @generated from message a2a.v1.DeleteTaskPushNotificationConfigRequest
 */
export type DeleteTaskPushNotificationConfigRequest = Message$1<"a2a.v1.DeleteTaskPushNotificationConfigRequest"> & {
  /**
   * The resource name of the config to delete.
   * Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message a2a.v1.DeleteTaskPushNotificationConfigRequest.
 * Use `create(DeleteTaskPushNotificationConfigRequestSchema)` to create a new message.
 */
export const DeleteTaskPushNotificationConfigRequestSchema: GenMessage<DeleteTaskPushNotificationConfigRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 39);

/**
 * --8<-- [start:SetTaskPushNotificationConfigRequest]
 *
 * @generated from message a2a.v1.CreateTaskPushNotificationConfigRequest
 */
export type CreateTaskPushNotificationConfigRequest = Message$1<"a2a.v1.CreateTaskPushNotificationConfigRequest"> & {
  /**
   * The parent task resource for this config.
   * Format: tasks/{task_id}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The ID for the new config.
   *
   * @generated from field: string config_id = 2;
   */
  configId: string;

  /**
   * The configuration to create.
   *
   * @generated from field: a2a.v1.TaskPushNotificationConfig config = 3;
   */
  config?: TaskPushNotificationConfig;
};

/**
 * Describes the message a2a.v1.CreateTaskPushNotificationConfigRequest.
 * Use `create(CreateTaskPushNotificationConfigRequestSchema)` to create a new message.
 */
export const CreateTaskPushNotificationConfigRequestSchema: GenMessage<CreateTaskPushNotificationConfigRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 40);

/**
 * --8<-- [start:TaskResubscriptionRequest]
 *
 * @generated from message a2a.v1.TaskSubscriptionRequest
 */
export type TaskSubscriptionRequest = Message$1<"a2a.v1.TaskSubscriptionRequest"> & {
  /**
   * The resource name of the task to subscribe to.
   * Format: tasks/{task_id}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message a2a.v1.TaskSubscriptionRequest.
 * Use `create(TaskSubscriptionRequestSchema)` to create a new message.
 */
export const TaskSubscriptionRequestSchema: GenMessage<TaskSubscriptionRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 41);

/**
 * --8<-- [start:ListTaskPushNotificationConfigRequest]
 *
 * @generated from message a2a.v1.ListTaskPushNotificationConfigRequest
 */
export type ListTaskPushNotificationConfigRequest = Message$1<"a2a.v1.ListTaskPushNotificationConfigRequest"> & {
  /**
   * The parent task resource.
   * Format: tasks/{task_id}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * For AIP-158 these fields are present. Usually not used/needed.
   * The maximum number of configurations to return.
   * If unspecified, all configs will be returned.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token received from a previous
   * ListTaskPushNotificationConfigRequest call.
   * Provide this to retrieve the subsequent page.
   * When paginating, all other parameters provided to
   * `ListTaskPushNotificationConfigRequest` must match the call that provided
   * the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message a2a.v1.ListTaskPushNotificationConfigRequest.
 * Use `create(ListTaskPushNotificationConfigRequestSchema)` to create a new message.
 */
export const ListTaskPushNotificationConfigRequestSchema: GenMessage<ListTaskPushNotificationConfigRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 42);

/**
 * --8<-- [start:GetAuthenticatedExtendedCardRequest]
 *
 * Empty. Added to fix linter violation.
 *
 * @generated from message a2a.v1.GetAgentCardRequest
 */
export type GetAgentCardRequest = Message$1<"a2a.v1.GetAgentCardRequest"> & {
};

/**
 * Describes the message a2a.v1.GetAgentCardRequest.
 * Use `create(GetAgentCardRequestSchema)` to create a new message.
 */
export const GetAgentCardRequestSchema: GenMessage<GetAgentCardRequest> = /*@__PURE__*/
  messageDesc(file_a2a, 43);

/**
 * ////// Response Messages ///////////
 * --8<-- [start:SendMessageSuccessResponse]
 *
 * @generated from message a2a.v1.SendMessageResponse
 */
export type SendMessageResponse = Message$1<"a2a.v1.SendMessageResponse"> & {
  /**
   * @generated from oneof a2a.v1.SendMessageResponse.payload
   */
  payload: {
    /**
     * @generated from field: a2a.v1.Task task = 1;
     */
    value: Task;
    case: "task";
  } | {
    /**
     * @generated from field: a2a.v1.Message msg = 2 [json_name = "message"];
     */
    value: Message;
    case: "msg";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message a2a.v1.SendMessageResponse.
 * Use `create(SendMessageResponseSchema)` to create a new message.
 */
export const SendMessageResponseSchema: GenMessage<SendMessageResponse> = /*@__PURE__*/
  messageDesc(file_a2a, 44);

/**
 * --8<-- [start:SendStreamingMessageSuccessResponse]
 * The stream response for a message. The stream should be one of the following
 * sequences:
 * If the response is a message, the stream should contain one, and only one,
 * message and then close
 * If the response is a task lifecycle, the first response should be a Task
 * object followed by zero or more TaskStatusUpdateEvents and
 * TaskArtifactUpdateEvents. The stream should complete when the Task
 * if in an interrupted or terminal state. A stream that ends before these
 * conditions are met are
 *
 * @generated from message a2a.v1.StreamResponse
 */
export type StreamResponse = Message$1<"a2a.v1.StreamResponse"> & {
  /**
   * @generated from oneof a2a.v1.StreamResponse.payload
   */
  payload: {
    /**
     * @generated from field: a2a.v1.Task task = 1;
     */
    value: Task;
    case: "task";
  } | {
    /**
     * @generated from field: a2a.v1.Message msg = 2 [json_name = "message"];
     */
    value: Message;
    case: "msg";
  } | {
    /**
     * @generated from field: a2a.v1.TaskStatusUpdateEvent status_update = 3;
     */
    value: TaskStatusUpdateEvent;
    case: "statusUpdate";
  } | {
    /**
     * @generated from field: a2a.v1.TaskArtifactUpdateEvent artifact_update = 4;
     */
    value: TaskArtifactUpdateEvent;
    case: "artifactUpdate";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message a2a.v1.StreamResponse.
 * Use `create(StreamResponseSchema)` to create a new message.
 */
export const StreamResponseSchema: GenMessage<StreamResponse> = /*@__PURE__*/
  messageDesc(file_a2a, 45);

/**
 * --8<-- [start:ListTaskPushNotificationConfigSuccessResponse]
 *
 * @generated from message a2a.v1.ListTaskPushNotificationConfigResponse
 */
export type ListTaskPushNotificationConfigResponse = Message$1<"a2a.v1.ListTaskPushNotificationConfigResponse"> & {
  /**
   * The list of push notification configurations.
   *
   * @generated from field: repeated a2a.v1.TaskPushNotificationConfig configs = 1;
   */
  configs: TaskPushNotificationConfig[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message a2a.v1.ListTaskPushNotificationConfigResponse.
 * Use `create(ListTaskPushNotificationConfigResponseSchema)` to create a new message.
 */
export const ListTaskPushNotificationConfigResponseSchema: GenMessage<ListTaskPushNotificationConfigResponse> = /*@__PURE__*/
  messageDesc(file_a2a, 46);

/**
 * --8<-- [start:TaskState]
 * The set of states a Task can be in.
 *
 * @generated from enum a2a.v1.TaskState
 */
export enum TaskState {
  /**
   * @generated from enum value: TASK_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Represents the status that acknowledges a task is created
   *
   * @generated from enum value: TASK_STATE_SUBMITTED = 1;
   */
  SUBMITTED = 1,

  /**
   * Represents the status that a task is actively being processed
   *
   * @generated from enum value: TASK_STATE_WORKING = 2;
   */
  WORKING = 2,

  /**
   * Represents the status a task is finished. This is a terminal state
   *
   * @generated from enum value: TASK_STATE_COMPLETED = 3;
   */
  COMPLETED = 3,

  /**
   * Represents the status a task is done but failed. This is a terminal state
   *
   * @generated from enum value: TASK_STATE_FAILED = 4;
   */
  FAILED = 4,

  /**
   * Represents the status a task was cancelled before it finished.
   * This is a terminal state.
   *
   * @generated from enum value: TASK_STATE_CANCELLED = 5;
   */
  CANCELLED = 5,

  /**
   * Represents the status that the task requires information to complete.
   * This is an interrupted state.
   *
   * @generated from enum value: TASK_STATE_INPUT_REQUIRED = 6;
   */
  INPUT_REQUIRED = 6,

  /**
   * Represents the status that the agent has decided to not perform the task.
   * This may be done during initial task creation or later once an agent
   * has determined it can't or won't proceed. This is a terminal state.
   *
   * @generated from enum value: TASK_STATE_REJECTED = 7;
   */
  REJECTED = 7,

  /**
   * Represents the state that some authentication is needed from the upstream
   * client. Authentication is expected to come out-of-band thus this is not
   * an interrupted or terminal state.
   *
   * @generated from enum value: TASK_STATE_AUTH_REQUIRED = 8;
   */
  AUTH_REQUIRED = 8,
}

/**
 * Describes the enum a2a.v1.TaskState.
 */
export const TaskStateSchema: GenEnum<TaskState> = /*@__PURE__*/
  enumDesc(file_a2a, 0);

/**
 * @generated from enum a2a.v1.Role
 */
export enum Role {
  /**
   * @generated from enum value: ROLE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * USER role refers to communication from the client to the server.
   *
   * @generated from enum value: ROLE_USER = 1;
   */
  USER = 1,

  /**
   * AGENT role refers to communication from the server to the client.
   *
   * @generated from enum value: ROLE_AGENT = 2;
   */
  AGENT = 2,
}

/**
 * Describes the enum a2a.v1.Role.
 */
export const RoleSchema: GenEnum<Role> = /*@__PURE__*/
  enumDesc(file_a2a, 1);

/**
 * A2AService defines the gRPC version of the A2A protocol. This has a slightly
 * different shape than the JSONRPC version to better conform to AIP-127,
 * where appropriate. The nouns are AgentCard, Message, Task and
 * TaskPushNotificationConfig.
 * - Messages are not a standard resource so there is no get/delete/update/list
 *   interface, only a send and stream custom methods.
 * - Tasks have a get interface and custom cancel and subscribe methods.
 * - TaskPushNotificationConfig are a resource whose parent is a task.
 *   They have get, list and create methods.
 * - AgentCard is a static resource with only a get method.
 *
 * @generated from service a2a.v1.A2AService
 */
export const A2AService: GenService<{
  /**
   * Send a message to the agent. This is a blocking call that will return the
   * task once it is completed, or a LRO if requested.
   *
   * @generated from rpc a2a.v1.A2AService.SendMessage
   */
  sendMessage: {
    methodKind: "unary";
    input: typeof SendMessageRequestSchema;
    output: typeof SendMessageResponseSchema;
  },
  /**
   * SendStreamingMessage is a streaming call that will return a stream of
   * task update events until the Task is in an interrupted or terminal state.
   *
   * @generated from rpc a2a.v1.A2AService.SendStreamingMessage
   */
  sendStreamingMessage: {
    methodKind: "server_streaming";
    input: typeof SendMessageRequestSchema;
    output: typeof StreamResponseSchema;
  },
  /**
   * Get the current state of a task from the agent.
   *
   * @generated from rpc a2a.v1.A2AService.GetTask
   */
  getTask: {
    methodKind: "unary";
    input: typeof GetTaskRequestSchema;
    output: typeof TaskSchema;
  },
  /**
   * List tasks with optional filtering and pagination.
   *
   * @generated from rpc a2a.v1.A2AService.ListTasks
   */
  listTasks: {
    methodKind: "unary";
    input: typeof ListTasksRequestSchema;
    output: typeof ListTasksResponseSchema;
  },
  /**
   * Cancel a task from the agent. If supported one should expect no
   * more task updates for the task.
   *
   * @generated from rpc a2a.v1.A2AService.CancelTask
   */
  cancelTask: {
    methodKind: "unary";
    input: typeof CancelTaskRequestSchema;
    output: typeof TaskSchema;
  },
  /**
   * TaskSubscription is a streaming call that will return a stream of task
   * update events. This attaches the stream to an existing in process task.
   * If the task is complete the stream will return the completed task (like
   * GetTask) and close the stream.
   *
   * @generated from rpc a2a.v1.A2AService.TaskSubscription
   */
  taskSubscription: {
    methodKind: "server_streaming";
    input: typeof TaskSubscriptionRequestSchema;
    output: typeof StreamResponseSchema;
  },
  /**
   * Set a push notification config for a task.
   *
   * @generated from rpc a2a.v1.A2AService.CreateTaskPushNotificationConfig
   */
  createTaskPushNotificationConfig: {
    methodKind: "unary";
    input: typeof CreateTaskPushNotificationConfigRequestSchema;
    output: typeof TaskPushNotificationConfigSchema;
  },
  /**
   * Get a push notification config for a task.
   *
   * @generated from rpc a2a.v1.A2AService.GetTaskPushNotificationConfig
   */
  getTaskPushNotificationConfig: {
    methodKind: "unary";
    input: typeof GetTaskPushNotificationConfigRequestSchema;
    output: typeof TaskPushNotificationConfigSchema;
  },
  /**
   * Get a list of push notifications configured for a task.
   *
   * @generated from rpc a2a.v1.A2AService.ListTaskPushNotificationConfig
   */
  listTaskPushNotificationConfig: {
    methodKind: "unary";
    input: typeof ListTaskPushNotificationConfigRequestSchema;
    output: typeof ListTaskPushNotificationConfigResponseSchema;
  },
  /**
   * GetAgentCard returns the agent card for the agent.
   *
   * @generated from rpc a2a.v1.A2AService.GetAgentCard
   */
  getAgentCard: {
    methodKind: "unary";
    input: typeof GetAgentCardRequestSchema;
    output: typeof AgentCardSchema;
  },
  /**
   * Delete a push notification config for a task.
   *
   * @generated from rpc a2a.v1.A2AService.DeleteTaskPushNotificationConfig
   */
  deleteTaskPushNotificationConfig: {
    methodKind: "unary";
    input: typeof DeleteTaskPushNotificationConfigRequestSchema;
    output: typeof EmptySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_a2a, 0);

